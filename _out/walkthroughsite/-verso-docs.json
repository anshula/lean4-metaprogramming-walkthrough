{"99":
 "<code>Lean.Parser.Category.term : Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`term` is the builtin syntax category for terms. A term denotes an expression\nin lean's type theory, for example `2 + 2` is a term. The difference between\n`Term` and `Expr` is that the former is a kind of syntax, while the latter is\nthe result of elaboration. For example `by simp` is also a `Term`, but it elaborates\nto different `Expr`s depending on the context. </code>",
 "98":
 "<code><span class=\"literal string\">\"print_hypothesis_by_name\"</span> : String</code>",
 "97": "<code>Lean.Elab.Tactic.getFVarId (id : Syntax) : TacticM FVarId</code>",
 "96":
 "<code>Lean.TSyntax (ks : SyntaxNodeKinds) : Type</code><span class=\"sep\"></span><code class=\"docstring\">Typed syntax, which tracks the potential kinds of the `Syntax` it contains.\n\nWhile syntax quotations produce or expect `TSyntax` values of the correct kinds, this is not\notherwise enforced; it can easily be circumvented by direct use of the constructor.\n</code>",
 "95": "<code>TSyntax `term</code>",
 "94":
 "<code>getHypothesisByTerm (h : TSyntax `term) : TacticM LocalDecl</code>",
 "93": "<code>Lean.FVarId.name (self : FVarId) : Name</code>",
 "92":
 "<code>Lean.LocalDecl.fvarId : LocalDecl → FVarId</code><span class=\"sep\"></span><code class=\"docstring\">The unique id of the free variable. </code>",
 "91":
 "<code>Lean.FVarId : Type</code><span class=\"sep\"></span><code class=\"docstring\">The unique free variable identifier. It is just a hierarchical name,\nbut we wrap it in `FVarId` to make sure they don't get mixed up with `MVarId`.\n\nThis is not the user-facing name for a free variable. This information is stored\nin the local context (`LocalContext`). The unique identifiers are generated using\na `NameGenerator`.\n</code>",
 "90": "<code>FVarId</code>",
 "9":
 "<code>Lean.Elab.Tactic.getMainGoal : TacticM MVarId</code><span class=\"sep\"></span><code class=\"docstring\">Return the first goal. </code>",
 "89": "<code>getHypothesisByFVarId (h : FVarId) : TacticM LocalDecl</code>",
 "88":
 "<code class=\"docstring\">Macro for throwing error exceptions. The argument can be an interpolated string.\nIt is a convenient way of building `MessageData` objects.\nThe result of `getRef` is used as position information.\nRecall that `getRef` returns the current \"reference\" syntax.\n</code>",
 "87":
 "<code>Lean.LocalDecl : Type</code><span class=\"sep\"></span><code class=\"docstring\">A declaration for a `LocalContext`. This is used to register which free variables are in scope.\n\nSee `LocalDecl.index`, `LocalDecl.fvarId`, `LocalDecl.userName`, `LocalDecl.type` for accessors for\narguments common to both constructors.\n</code>",
 "86":
 "<code>Lean.Name : Type</code><span class=\"sep\"></span><code class=\"docstring\">Hierarchical names consist of a sequence of components, each of\nwhich is either a string or numeric, that are written separated by dots (`.`).\n\nHierarchical names are used to name declarations and for creating\nunique identifiers for free variables and metavariables.\n\nYou can create hierarchical names using a backtick:\n```\n`Lean.Meta.whnf\n```\nIt is short for `.str (.str (.str .anonymous \"Lean\") \"Meta\") \"whnf\"`.\n\nYou can use double backticks to request Lean to statically check whether the name\ncorresponds to a Lean declaration in scope.\n```\n``Lean.Meta.whnf\n```\nIf the name is not in scope, Lean will report an error.\n\nThere are two ways to convert a `String` to a `Name`:\n\n 1. `Name.mkSimple` creates a name with a single string component.\n\n 2. `String.toName` first splits the string into its dot-separated\n    components, and then creates a hierarchical name.\n</code>",
 "85": "<code>getHypothesisByName (h : Name) : TacticM LocalDecl</code>",
 "84":
 "<code>Unit : Type</code><span class=\"sep\"></span><code class=\"docstring\">The canonical type with one element. This element is written `()`.\n\n`Unit` has a number of uses:\n* It can be used to model control flow that returns from a function call without providing other\n  information.\n* Monadic actions that return `Unit` have side effects without computing values.\n* In polymorphic types, it can be used to indicate that no data is to be stored in a particular\n  field.\n</code>",
 "83":
 "<code>Lean.Elab.Tactic.TacticM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The tactic monad, which extends the term elaboration monad `TermElabM` with state that contains the\ncurrent goals (`Lean.Elab.Tactic.State`, accessible via `MonadStateOf`) and local information about\nthe current tactic's name and whether error recovery is enabled (`Lean.Elab.Tactic.Context`,\naccessible via `MonadReaderOf`).\n</code>",
 "82": "<code>printHypotheses : TacticM Unit</code>",
 "81":
 "<code>Lean.Elab.Tactic.withMainContext {α : Type} (x : TacticM α) : TacticM α</code><span class=\"sep\"></span><code class=\"docstring\">Execute `x` using the main goal local context and instances </code>",
 "80":
 "<code><span class=\"literal string\">\"print_hypotheses''\"</span> : String</code>",
 "8": "<code>MVarId</code>",
 "79":
 "<code>Lean.MetavarDecl.lctx (self : MetavarDecl) : LocalContext</code><span class=\"sep\"></span><code class=\"docstring\">The local context containing the free variables that the mvar is permitted to depend upon. </code>",
 "78":
 "<code>Lean.MVarId.getDecl (mvarId : MVarId) : MetaM MetavarDecl</code><span class=\"sep\"></span><code class=\"docstring\">Return `mvarId` declaration in the current metavariable context.\nThrow an exception if `mvarId` is not declared in the current metavariable context.\n</code>",
 "77":
 "<code><span class=\"literal string\">\"print_hypotheses'\"</span> : String</code>",
 "76":
 "<code class=\"docstring\">`rw` is like `rewrite`, but also tries to close the goal by \"cheap\" (reducible) `rfl` afterwards.\n</code>",
 "75":
 "<code>HSub.hSub.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HSub α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a - b` computes the difference of `a` and `b`.\nThe meaning of this notation is type-dependent.\n* For natural numbers, this operator saturates at 0: `a - b = 0` when `a ≤ b`. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `-` in identifiers is `sub` (when used as a binary operator).</code>",
 "74": "<code>b - a = 1</code>",
 "73":
 "<code class=\"docstring\">The `have` tactic is for adding hypotheses to the local context of the main goal.\n* `have h : t := e` adds the hypothesis `h : t` if `e` is a term of type `t`.\n* `have h := e` uses the type of `e` for `t`.\n* `have : t := e` and `have := e` use `this` for the name of the hypothesis.\n* `have pat := e` for a pattern `pat` is equivalent to `match e with | pat =&gt; _`,\n  where `_` stands for the tactics that follow this one.\n  It is convenient for types that have only one applicable constructor.\n  For example, given `h : p ∧ q ∧ r`, `have ⟨h₁, h₂, h₃⟩ := h` produces the\n  hypotheses `h₁ : p`, `h₂ : q`, and `h₃ : r`.\n</code>",
 "72":
 "<code>Nat : Type</code><span class=\"sep\"></span><code class=\"docstring\">The natural numbers, starting at zero.\n\nThis type is special-cased by both the kernel and the compiler, and overridden with an efficient\nimplementation. Both use a fast arbitrary-precision arithmetic library (usually\n[GMP](https://gmplib.org/)); at runtime, `Nat` values that are sufficiently small are unboxed.\n</code>",
 "71": "<code>b = 3</code>",
 "70": "<code>a = 2</code>",
 "7":
 "<code><span class=\"literal string\">\"print_goal\"</span> : String</code>",
 "69":
 "<code>Lean.MessageData.compose : MessageData → MessageData → MessageData</code><span class=\"sep\"></span><code class=\"docstring\">Lifted `Format.compose` </code>",
 "68":
 "<code>Lean.LocalDecl.type : LocalDecl → Expr</code><span class=\"sep\"></span><code class=\"docstring\">The type of the variable. </code>",
 "67": "<code>Expr</code>",
 "66":
 "<code>Lean.LocalDecl.userName : LocalDecl → Name</code><span class=\"sep\"></span><code class=\"docstring\">The pretty-printable name of the variable. </code>",
 "65": "<code>Name</code>",
 "64":
 "<code class=\"docstring\">`continue` skips to the next iteration of the surrounding `for` loop. </code>",
 "63":
 "<code>Lean.LocalDecl.isImplementationDetail (d : LocalDecl) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Is the local declaration an implementation-detail hypothesis\n(including auxiliary declarations)?\n</code>",
 "62":
 "<code>Lean.MonadLCtx.getLCtx {m : Type → Type} [self : MonadLCtx m] : m LocalContext</code>",
 "61": "<code>LocalDecl</code>",
 "60":
 "<code>Std.Format.nil : Format</code><span class=\"sep\"></span><code class=\"docstring\">The empty format. </code>",
 "6":
 "<code class=\"docstring\">`trivial` tries different simple tactics (e.g., `rfl`, `contradiction`, ...)\nto close the current goal.\nYou can use the command `macro_rules` to extend the set of tactics used. Example:\n```\nmacro_rules | `(tactic| trivial) =&gt; `(tactic| simp)\n```\n</code>",
 "59":
 "<code>Lean.MessageData.ofFormat (fmt : Format) : MessageData</code><span class=\"sep\"></span><code class=\"docstring\">Eagerly formatted text. </code>",
 "58":
 "<code>Lean.MessageData : Type</code><span class=\"sep\"></span><code class=\"docstring\">Structured message data. We use it for reporting errors, trace messages, etc. </code>",
 "57": "<code>MessageData</code>",
 "56":
 "<code><span class=\"literal string\">\"print_hypotheses\"</span> : String</code>",
 "55":
 "<code><span class=\"literal string\">\"and_then'\"</span> : String</code>",
 "54":
 "<code><span class=\"literal string\">\" and_then \"</span> : String</code>",
 "53": "<code>TSyntax `tactic</code>",
 "52":
 "<code><span class=\"literal string\">\"and_then\"</span> : String</code>",
 "51":
 "<code class=\"docstring\">`simp_all` is a stronger version of `simp [*] at *` where the hypotheses and target\nare simplified multiple times until no simplification is applicable.\nOnly non-dependent propositional hypotheses are considered.\n</code>",
 "50":
 "<code>Lean.Parser.ident : Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `ident` parses a single identifier, possibly with namespaces, such as `foo` or\n`bar.baz`. The identifier must not be a declared token, so for example it will not match `\"def\"`\nbecause `def` is a keyword token. Tokens are implicitly declared by using them in string literals\nin parser declarations, so `syntax foo := \"bla\"` will make `bla` no longer legal as an identifier.\n\nIdentifiers can contain special characters or keywords if they are escaped using the `«»` characters:\n`«def»` is an identifier named `def`, and `«x»` is treated the same as `x`. This is useful for\nusing disallowed characters in identifiers such as `«foo.bar».baz` or `«hello world»`.\n\nThis parser has arity 1: it produces a `Syntax.ident` node containing the parsed identifier.\nYou can use `TSyntax.getId` to extract the name from the resulting syntax object. </code>",
 "5":
 "<code class=\"docstring\">`by tac` constructs a term of the expected type by running the tactic(s) `tac`. </code>",
 "49": "<code>TSyntax `ident</code>",
 "48":
 "<code><span class=\"literal string\">\"contrapos_with\"</span> : String</code>",
 "47":
 "<code class=\"docstring\">`revert x...` is the inverse of `intro x...`: it moves the given hypotheses\ninto the main goal's target type.\n</code>",
 "46": "<code>Q</code>",
 "45": "<code>P</code>",
 "44":
 "<code>Lean.Elab.admitGoal (mvarId : MVarId) : MetaM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Assign `mvarId := sorry` </code>",
 "43":
 "<code><span class=\"literal string\">\"my_sorry_elab\"</span> : String</code>",
 "42":
 "<code class=\"docstring\">The `sorry` tactic is a temporary placeholder for an incomplete tactic proof,\nclosing the main goal using `exact sorry`.\n\nThis is intended for stubbing-out incomplete parts of a proof while still having a syntactically correct proof skeleton.\nLean will give a warning whenever a proof uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a theorem depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n</code>",
 "41":
 "<code><span class=\"literal string\">\"my_sorry_macro\"</span> : String</code>",
 "40":
 "<code class=\"docstring\">The `sorry` term is a temporary placeholder for a missing proof or value.\n\nThe syntax is intended for stubbing-out incomplete parts of a value or proof while still having a syntactically correct skeleton.\nLean will give a warning whenever a declaration uses `sorry`, so you aren't likely to miss it,\nbut you can double check if a declaration depends on `sorry` by looking for `sorryAx` in the output\nof the `#print axioms my_thm` command, the axiom used by the implementation of `sorry`.\n\n\"Go to definition\" on `sorry` in the Infoview will go to the source position where it was introduced, if such information is available.\n\nEach `sorry` is guaranteed to be unique, so for example the following fails:\n```lean\nexample : (sorry : Nat) = sorry := rfl -- fails\n```\n\nSee also the `sorry` tactic, which is short for `exact sorry`.\n</code>",
 "4":
 "<code>True : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`True` is a proposition and has only an introduction rule, `True.intro : True`.\nIn other words, `True` is simply true, and has a canonical proof, `True.intro`\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n</code>",
 "39": "<code>my_sorry_theorem : True</code>",
 "38":
 "<code><span class=\"literal string\">\"contrapos\"</span> : String</code>",
 "37":
 "<code class=\"docstring\">The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or\nnon-dependent hypotheses. It has many variants:\n- `simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.\n- `simp [h₁, h₂, ..., hₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]` and the given `hᵢ`'s, where the `hᵢ`'s are expressions.-\n- If an `hᵢ` is a defined constant `f`, then `f` is unfolded. If `f` has equational lemmas associated\n  with it (and is not a projection or a `reducible` definition), these are used to rewrite with `f`.\n- `simp [*]` simplifies the main goal target using the lemmas tagged with the\n  attribute `[simp]` and all hypotheses.\n- `simp only [h₁, h₂, ..., hₙ]` is like `simp [h₁, h₂, ..., hₙ]` but does not use `[simp]` lemmas.\n- `simp [-id₁, ..., -idₙ]` simplifies the main goal target using the lemmas tagged\n  with the attribute `[simp]`, but removes the ones named `idᵢ`.\n- `simp at h₁ h₂ ... hₙ` simplifies the hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. If\n  the target or another hypothesis depends on `hᵢ`, a new simplified hypothesis\n  `hᵢ` is introduced, but the old one remains in the local context.\n- `simp at *` simplifies all the hypotheses and the target.\n- `simp [*] at *` simplifies target and all (propositional) hypotheses using the\n  other hypotheses.\n</code>",
 "36":
 "<code class=\"docstring\">`apply e` tries to match the current goal against the conclusion of `e`'s type.\nIf it succeeds, then the tactic returns as many subgoals as the number of premises that\nhave not been fixed by type inference or type class resolution.\nNon-dependent premises are added before dependent ones.\n\nThe `apply` tactic uses higher-order pattern matching, type class resolution,\nand first-order unification with dependent types.\n</code>",
 "35":
 "<code class=\"docstring\">Location specifications are used by many tactics that can operate on either the\nhypotheses or the goal. It can have one of the forms:\n* 'empty' is not actually present in this syntax, but most tactics use\n  `(location)?` matchers. It means to target the goal only.\n* `at h₁ ... hₙ`: target the hypotheses `h₁`, ..., `hₙ`\n* `at h₁ h₂ ⊢`: target the hypotheses `h₁` and `h₂`, and the goal\n* `at *`: target all hypotheses and the goal\n</code>",
 "34": "<code>P → Q</code>",
 "33": "<code>not_imp_not {a b : Prop} : ¬a → ¬b ↔ b → a</code>",
 "32":
 "<code class=\"docstring\">`rwa` is short-hand for `rw; assumption`. </code>",
 "31":
 "<code class=\"docstring\">Introduces one or more hypotheses, optionally naming and/or pattern-matching them.\nFor each hypothesis to be introduced, the remaining main goal's target type must\nbe a `let` or function type.\n\n* `intro` by itself introduces one anonymous hypothesis, which can be accessed\n  by e.g. `assumption`.\n* `intro x y` introduces two hypotheses and names them. Individual hypotheses\n  can be anonymized via `_`, or matched against a pattern:\n  ```lean\n  -- ... ⊢ α × β → ...\n  intro (a, b)\n  -- ..., a : α, b : β ⊢ ...\n  ```\n* Alternatively, `intro` can be combined with pattern matching much like `fun`:\n  ```lean\n  intro\n  | n + 1, 0 =&gt; tac\n  | ...\n  ```\n</code>",
 "30":
 "<code>Not (a : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Not p`, or `¬p`, is the negation of `p`. It is defined to be `p → False`,\nso if your goal is `¬p` you can use `intro h` to turn the goal into\n`h : p ⊢ False`, and if you have `hn : ¬p` and `h : p` then `hn h : False`\nand `(hn h).elim` will prove anything.\nFor more information: [Propositional Logic](https://lean-lang.org/theorem_proving_in_lean4/propositions_and_proofs.html#propositional-logic)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `¬` in identifiers is `not`.</code>",
 "3":
 "<code class=\"docstring\">`return e` inside of a `do` block makes the surrounding block evaluate to `pure e`,\nskipping any further statements.\nNote that uses of the `do` keyword in other syntax like in `for _ in _ do`\ndo not constitute a surrounding block in this sense;\nin supported editors, the corresponding `do` keyword of the surrounding block\nis highlighted when hovering over `return`.\n\n`return` not followed by a term starting on the same line is equivalent to `return ()`.\n</code>",
 "29": "<code>¬Q → ¬P</code>",
 "28":
 "<code class=\"docstring\">The universe of propositions. `Prop ≡ Sort 0`.\n\nEvery proposition is propositionally equal to either `True` or `False`. </code>",
 "27": "<code>Prop</code>",
 "26": "<code>ctrp {P Q : Prop} (contra : ¬Q → ¬P) : P → Q</code>",
 "25":
 "<code><span class=\"literal string\">\"clear_goals\"</span> : String</code>",
 "24":
 "<code>List.rotateLeft.{u} {α : Type u} (xs : List α) (i : ℕ := 1) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Rotates the elements of `xs` to the left, moving `i % xs.length` elements from the start of the list\nto the end.\n\n`O(|xs|)`.\n\nExamples:\n* `[1, 2, 3, 4, 5].rotateLeft 3 = [4, 5, 1, 2, 3]`\n* `[1, 2, 3, 4, 5].rotateLeft 5 = [1, 2, 3, 4, 5]`\n* `[1, 2, 3, 4, 5].rotateLeft 1 = [2, 3, 4, 5, 1]`\n</code>",
 "238":
 "<code>Lean.Expr.hasLooseBVars (e : Expr) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Return `true` if `e` contains any loose bound variables.\n\nThis is a constant time operation. </code>",
 "237":
 "<code>List.filter.{u} {α : Type u} (p : α → Bool) (l : List α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Returns the list of elements in `l` for which `p` returns `true`.\n\n`O(|l|)`.\n\nExamples:\n* `[1, 2, 5, 2, 7, 7].filter (· &gt; 2) = [5, 7, 7]`\n* `[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; false) = []`\n* `[1, 2, 5, 2, 7, 7].filter (fun _ =&gt; true) = [1, 2, 5, 2, 7, 7]`\n</code>",
 "236":
 "<code class=\"docstring\">`let` is used to declare a local definition. Example:\n```\nlet x := 1\nlet y := x + 1\nx + y\n```\nSince functions are first class citizens in Lean, you can use `let` to declare\nlocal functions too.\n```\nlet double := fun x =&gt; 2*x\ndouble (double 3)\n```\nFor recursive definitions, you should use `let rec`.\nYou can also perform pattern matching using `let`. For example,\nassume `p` has type `Nat × Nat`, then you can write\n```\nlet (x, y) := p\nx + y\n```\n</code>",
 "235":
 "<code>Lean.Expr.proj (typeName : Name) (idx : ℕ) (struct : Expr) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">Projection-expressions. They are redundant, but are used to create more compact\nterms, speedup reduction, and implement eta for structures.\nThe type of `struct` must be an structure-like inductive type. That is, it has only one\nconstructor, is not recursive, and it is not an inductive predicate. The kernel and elaborators\ncheck whether the `typeName` matches the type of `struct`, and whether the (zero-based) index\nis valid (i.e., it is smaller than the number of constructor fields).\nWhen exporting Lean developments to other systems, `proj` can be replaced with `typeName`.`rec`\napplications.\n\nExample, given `a : Nat × Bool`, `a.1` is represented as\n```\n.proj `Prod 0 a\n```\n</code>",
 "234":
 "<code>Lean.Expr.mdata (data : MData) (expr : Expr) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">Metadata (aka annotations).\n\nWe use annotations to provide hints to the pretty-printer,\nstore references to `Syntax` nodes, position information, and save information for\nelaboration procedures (e.g., we use the `inaccessible` annotation during elaboration to\nmark `Expr`s that correspond to inaccessible patterns).\n\nNote that `Expr.mdata data e` is definitionally equal to `e`.\n</code>",
 "233":
 "<code>Lean.Expr.lam (binderName : Name) (binderType body : Expr) (binderInfo : BinderInfo) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">A lambda abstraction (aka anonymous functions). It introduces a new binder for\nvariable `x` in scope for the lambda body.\n\nFor example, the expression `fun x : Nat =&gt; x` is represented as\n```\nExpr.lam `x (.const `Nat []) (.bvar 0) .default\n```\n</code>",
 "232":
 "<code class=\"docstring\">Pattern matching. `match e, ... with | p, ... =&gt; f | ...` matches each given\nterm `e` against each pattern `p` of a match alternative. When all patterns\nof an alternative match, the `match` term evaluates to the value of the\ncorresponding right-hand side `f` with the pattern variables bound to the\nrespective matched values.\nIf used as `match h : e, ... with | p, ... =&gt; f | ...`, `h : e = p` is available\nwithin `f`.\n\nWhen not constructing a proof, `match` does not automatically substitute variables\nmatched on in dependent variables' types. Use `match (generalizing := true) ...` to\nenforce this.\n\nSyntax quotations can also be used in a pattern match.\nThis matches a `Syntax` value against quotations, pattern variables, or `_`.\n\nQuoted identifiers only match identical identifiers - custom matching such as by the preresolved\nnames only should be done explicitly.\n\n`Syntax.atom`s are ignored during matching by default except when part of a built-in literal.\nFor users introducing new atoms, we recommend wrapping them in dedicated syntax kinds if they\nshould participate in matching.\nFor example, in\n```lean\nsyntax \"c\" (\"foo\" &lt;|&gt; \"bar\") ...\n```\n`foo` and `bar` are indistinguishable during matching, but in\n```lean\nsyntax foo := \"foo\"\nsyntax \"c\" (foo &lt;|&gt; \"bar\") ...\n```\nthey are not.\n</code>",
 "231":
 "<code>getSubexpressionsIn.getSubexpressionsInRec (e : Expr) (acc : List Expr) : List Expr</code>",
 "230": "<code>getSubexpressionsIn (e : Expr) : List Expr</code>",
 "23":
 "<code>Lean.Elab.Tactic.setGoals (mvarIds : List MVarId) : TacticM Unit</code>",
 "229":
 "<code>Lean.Meta.ppExpr (e : Expr) : MetaM Format</code><span class=\"sep\"></span><code class=\"docstring\">Pretty-print the given expression. </code>",
 "228": "<code>printPrettyExpression (e : Expr) : MetaM Unit</code>",
 "227": "<code>natExpr : ℕ → Expr</code>",
 "226": "<code>«one» : Expr</code>",
 "225": "<code><span class=\"literal string\">\"one\"</span> : String</code>",
 "224": "<code>«zero» : Expr</code>",
 "223": "<code><span class=\"literal string\">\"zero\"</span> : String</code>",
 "222":
 "<code>Nat.succ (n : ℕ) : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">The successor of a natural number `n`.\n\nUsing `Nat.succ n` should usually be avoided in favor of `n + 1`, which is the [simp normal\nform](https://lean-lang.org/doc/reference/4.19.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "221": "<code>one : Expr</code>",
 "220":
 "<code>Nat.zero : ℕ</code><span class=\"sep\"></span><code class=\"docstring\">Zero, the smallest natural number.\n\nUsing `Nat.zero` explicitly should usually be avoided in favor of the literal `0`, which is the\n[simp normal form](https://lean-lang.org/doc/reference/4.19.0/find/?domain=Verso.Genre.Manual.section&name=simp-normal-forms).\n</code>",
 "22":
 "<code><span class=\"literal string\">\"rotate_goals\"</span> : String</code>",
 "219": "<code>zero : Expr</code>",
 "218":
 "<code>Ne.{u} {α : Sort u} (a b : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`a ≠ b`, or `Ne a b` is defined as `¬ (a = b)` or `a = b → False`,\nand asserts that `a` and `b` are not equal.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≠` in identifiers is `ne`.</code>",
 "217":
 "<code>Lean.mkAppN (f : Expr) (args : Array Expr) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">`mkAppN f #[a₀, ..., aₙ]` constructs the application `f a₀ a₁ ... aₙ`.\n</code>",
 "216":
 "<code>Array.toList.{u} {α : Type u} (self : Array α) : List α</code><span class=\"sep\"></span><code class=\"docstring\">Converts an `Array α` into a `List α` that contains the same elements in the same order.\n\nAt runtime, this is implemented by `Array.toListImpl` and is `O(n)` in the length of the\narray.\n</code>",
 "215":
 "<code>Array.mapM.{u, v, w} {α : Type u} {β : Type v} {m : Type v → Type w} [Monad m] (f : α → m β) («as» : Array α) :\n  m (Array β)</code><span class=\"sep\"></span><code class=\"docstring\">Applies the monadic action `f` to every element in the array, left-to-right, and returns the array\nof results.\n</code>",
 "214":
 "<code>Lean.Meta.forallMetaTelescope (e : Expr) (kind : MetavarKind := MetavarKind.natural) :\n  MetaM (Array Expr × Array BinderInfo × Expr)</code><span class=\"sep\"></span><code class=\"docstring\">Given `e` of the form `forall ..xs, A`, this combinator will create a new\nmetavariable for each `x` in `xs` and instantiate `A` with these.\nReturns a product containing\n- the new metavariables\n- the binder info for the `xs`\n- the instantiated `A`\n</code>",
 "213": "<code>Array Expr</code>",
 "212":
 "<code>Lean.Elab.Tactic.elabTerm (stx : Syntax) (expectedType? : Option Expr) (mayPostpone : Bool := false) : TacticM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Elaborate `stx` in the current `MVarContext`. If given, the `expectedType` will be used to help\nelaboration but not enforced (use `elabTermEnsuringType` to enforce an expected type). </code>",
 "211":
 "<code><span class=\"literal string\">\"apply_to_target\"</span> : String</code>",
 "210":
 "<code>Nat.not_prime_mul {a b : ℕ} (a1 : a ≠ 1) (b1 : b ≠ 1) : ¬Nat.Prime (a * b)</code>",
 "21":
 "<code class=\"docstring\">This tactic applies to a goal whose target has the form `x ~ x`,\nwhere `~` is equality, heterogeneous equality or any relation that\nhas a reflexivity lemma tagged with the attribute @[refl].\n</code>",
 "209":
 "<code>Lean.mkArrow (d b : Expr) : CoreM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Creates the expression `d → b` </code>",
 "208": "<code>getGoalType : TacticM Expr</code>",
 "207":
 "<code><span class=\"literal string\">\"apply_hypothesis_unif\"</span> : String</code>",
 "206":
 "<code>Lean.instantiateMVars {m : Type → Type} [Monad m] [MonadMCtx m] (e : Expr) : m Expr</code>",
 "205": "<code>Bool</code>",
 "204":
 "<code>Lean.Elab.Term.elabTermAndSynthesize (stx : Syntax) (expectedType? : Option Expr) : TermElabM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Elaborate `stx`, and make sure all pending synthetic metavariables created while elaborating `stx` are solved. </code>",
 "203": "<code><span class=\"literal string\">\"and\"</span> : String</code>",
 "202":
 "<code><span class=\"literal string\">\"try_to_unify\"</span> : String</code>",
 "201":
 "<code><span class=\"literal string\">\"apply_hypothesis_defeq\"</span> : String</code>",
 "200":
 "<code>HMul.hMul.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HMul α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a * b` computes the product of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `*` in identifiers is `mul`.</code>",
 "20":
 "<code class=\"docstring\">`all_goals tac` runs `tac` on each goal, concatenating the resulting goals.\nIf the tactic fails on any goal, the entire `all_goals` tactic fails.\n\nSee also `any_goals tac`.\n</code>",
 "2":
 "<code>Lean.Parser.Category.tactic : Parser.Category</code><span class=\"sep\"></span><code class=\"docstring\">`tactic` is the builtin syntax category for tactics. These appear after\n`by` in proofs, and they are programs that take in the proof context\n(the hypotheses in scope plus the type of the term to synthesize) and construct\na term of the expected type. For example, `simp` is a tactic, used in:\n```\nexample : 2 + 2 = 4 := by simp\n```\n</code>",
 "199":
 "<code>even_iff_two_dvd.{u_2} {α : Type u_2} [Semiring α] {a : α} : Even a ↔ 2 ∣ a</code>",
 "198":
 "<code>Even.{u_2} {α : Type u_2} [Add α] (a : α) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">An element `a` of a type `α` with addition satisfies `Even a` if `a = r + r`,\nfor some `r : α`.</code>",
 "197": "<code>Even 2 → Even 4</code>",
 "196":
 "<code>Lean.Expr.app (fn arg : Expr) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">A function application.\n\nFor example, the natural number one, i.e. `Nat.succ Nat.zero` is represented as\n``Expr.app (.const `Nat.succ []) (.const .zero [])``.\nNote that multiple arguments are represented using partial application.\n\nFor example, the two argument application `f x y` is represented as\n`Expr.app (.app f x) y`.\n</code>",
 "195":
 "<code class=\"docstring\">A shorthand for `panic! \"unreachable code has been reached\"`. </code>",
 "194":
 "<code>Lean.Expr.forallE (binderName : Name) (binderType body : Expr) (binderInfo : BinderInfo) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">A dependent arrow `(a : α) → β)` (aka forall-expression) where `β` may dependent\non `a`. Note that this constructor is also used to represent non-dependent arrows\nwhere `β` does not depend on `a`.\n\nFor example:\n- `forall x : Prop, x ∧ x`:\n  ```lean\n  Expr.forallE `x (.sort .zero)\n    (.app (.app (.const `And []) (.bvar 0)) (.bvar 0)) .default\n  ```\n- `Nat → Bool`:\n  ```lean\n  Expr.forallE `a (.const `Nat [])\n    (.const `Bool []) .default\n  ```\n</code>",
 "193":
 "<code>Lean.Expr.isArrow (e : Expr) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Return `true` if `e` is a non-dependent arrow.\nRemark: the following function assumes `e` does not have loose bound variables.\n</code>",
 "192":
 "<code>guard.{v} {f : Type → Type v} [Alternative f] (p : Prop) [Decidable p] : f Unit</code><span class=\"sep\"></span><code class=\"docstring\">If the proposition `p` is true, does nothing, else fails (using `failure`).\n</code>",
 "191":
 "<code><span class=\"literal string\">\"apply_hypothesis\"</span> : String</code>",
 "190": "<code>createGoal' (goalType : Expr) : TacticM Expr</code>",
 "19":
 "<code class=\"docstring\">If the main goal's target type is an inductive type, `constructor` solves it with\nthe first matching constructor, or else fails.\n</code>",
 "189":
 "<code class=\"docstring\">`decide` attempts to prove the main goal (with target type `p`) by synthesizing an instance of `Decidable p`\nand then reducing that instance to evaluate the truth value of `p`.\nIf it reduces to `isTrue h`, then `h` is a proof of `p` that closes the goal.\n\nThe target is not allowed to contain local variables or metavariables.\nIf there are local variables, you can first try using the `revert` tactic with these local variables to move them into the target,\nor you can use the `+revert` option, described below.\n\nOptions:\n- `decide +revert` begins by reverting local variables that the target depends on,\n  after cleaning up the local context of irrelevant variables.\n  A variable is *relevant* if it appears in the target, if it appears in a relevant variable,\n  or if it is a proposition that refers to a relevant variable.\n- `decide +kernel` uses kernel for reduction instead of the elaborator.\n  It has two key properties: (1) since it uses the kernel, it ignores transparency and can unfold everything,\n  and (2) it reduces the `Decidable` instance only once instead of twice.\n- `decide +native` uses the native code compiler (`#eval`) to evaluate the `Decidable` instance,\n  admitting the result via the `Lean.ofReduceBool` axiom.\n  This can be significantly more efficient than using reduction, but it is at the cost of increasing the size\n  of the trusted code base.\n  Namely, it depends on the correctness of the Lean compiler and all definitions with an `@[implemented_by]` attribute.\n  Like with `+kernel`, the `Decidable` instance is evaluated only once.\n\nLimitation: In the default mode or `+kernel` mode, since `decide` uses reduction to evaluate the term,\n`Decidable` instances defined by well-founded recursion might not work because evaluating them requires reducing proofs.\nReduction can also get stuck on `Decidable` instances with `Eq.rec` terms.\nThese can appear in instances defined using tactics (such as `rw` and `simp`).\nTo avoid this, create such instances using definitions such as `decidable_of_iff` instead.\n\n## Examples\n\nProving inequalities:\n```lean\nexample : 2 + 2 ≠ 5 := by decide\n```\n\nTrying to prove a false proposition:\n```lean\nexample : 1 ≠ 1 := by decide\n/-\ntactic 'decide' proved that the proposition\n  1 ≠ 1\nis false\n-/\n```\n\nTrying to prove a proposition whose `Decidable` instance fails to reduce\n```lean\nopaque unknownProp : Prop\n\nopen scoped Classical in\nexample : unknownProp := by decide\n/-\ntactic 'decide' failed for proposition\n  unknownProp\nsince its 'Decidable' instance reduced to\n  Classical.choice ⋯\nrather than to the 'isTrue' constructor.\n-/\n```\n\n## Properties and relations\n\nFor equality goals for types with decidable equality, usually `rfl` can be used in place of `decide`.\n```lean\nexample : 1 + 1 = 2 := by decide\nexample : 1 + 1 = 2 := by rfl\n```\n</code>",
 "188":
 "<code>LE.le.{u} {α : Type u} [self : LE α] : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The less-equal relation: `x ≤ y` \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `≤` in identifiers is `le`.\n\n * The recommended spelling of `&lt;=` in identifiers is `le` (prefer `≤` over `&lt;=`).</code>",
 "187":
 "<code>HPow.hPow.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HPow α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a ^ b` computes `a` to the power of `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `^` in identifiers is `pow`.</code>",
 "186":
 "<code>Nat.Prime.not_prime_pow {x n : ℕ} (hn : 2 ≤ n) : ¬Nat.Prime (x ^ n)</code>",
 "185": "<code>∀ (n m : ℕ), n + m = m + n</code>",
 "184":
 "<code>Lean.ConstantInfo.value! (info : ConstantInfo) (allowOpaque : Bool := false) : Expr</code>",
 "183": "<code>Lean.ConstantInfo.type (d : ConstantInfo) : Expr</code>",
 "182":
 "<code>Lean.TSyntax.getName (s : NameLit) : Name</code><span class=\"sep\"></span><code class=\"docstring\">Decodes a quoted name literal, returning the name.\n\nReturns `Lean.Name.anonymous` if the syntax is malformed.\n</code>",
 "181":
 "<code>Lean.Environment.find? (env : Environment) (n : Name) (skipRealize : Bool := false) : Option ConstantInfo</code><span class=\"sep\"></span><code class=\"docstring\">Like `findAsync?`, but blocks until the constant's info is fully available.  </code>",
 "180": "<code>ConstantInfo</code>",
 "18":
 "<code>And (a b : Prop) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`And a b`, or `a ∧ b`, is the conjunction of propositions. It can be\nconstructed and destructed like a pair: if `ha : a` and `hb : b` then\n`⟨ha, hb⟩ : a ∧ b`, and if `h : a ∧ b` then `h.left : a` and `h.right : b`.\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `∧` in identifiers is `and`.\n\n * The recommended spelling of `/\\` in identifiers is `and` (prefer `∧` over `/\\`).</code>",
 "179":
 "<code>Lean.Parser.nameLit : Parser.Parser</code><span class=\"sep\"></span><code class=\"docstring\">The parser `name` parses a name literal like `` `foo``. The syntax is the same as for identifiers\n(see `ident`) but with a leading backquote.\n\nThis parser has arity 1: it produces a `nameLitKind` node containing the raw literal\n(including the backquote).\nYou can use `TSyntax.getName` to extract the name from the resulting syntax object. </code>",
 "178": "<code>TSyntax `name</code>",
 "177":
 "<code><span class=\"literal string\">\"add_theorem_as_hypothesis\"</span> : String</code>",
 "176":
 "<code><span class=\"literal string\">\"create_bogus_hypothesis'\"</span> : String</code>",
 "175":
 "<code>Lean.Meta.inferType : Expr → MetaM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Returns the inferred type of the given expression. Assumes the expression is type-correct.\n\nThe type inference algorithm does not do general type checking.\nType inference only looks at subterms that are necessary for determining an expression's type,\nand as such if `inferType` succeeds it does *not* mean the term is type-correct.\nIf an expression is sufficiently ill-formed that it prevents `inferType` from computing a type,\nthen it will fail with a type error.\n\nFor typechecking during elaboration, see `Lean.Meta.check`.\n(Note that we do not guarantee that the elaborator typechecker is as correct or as efficient as\nthe kernel typechecker. The kernel typechecker is invoked when a definition is added to the environment.)\n\nHere are examples of type-incorrect terms for which `inferType` succeeds:\n```lean\nimport Lean\n\nopen Lean Meta\n\n/--\n`@id.{1} Bool Nat.zero`.\nIn general, the type of `@id α x` is `α`.\n-/\ndef e1 : Expr := mkApp2 (.const ``id [1]) (.const ``Bool []) (.const ``Nat.zero [])\n#eval inferType e1\n-- Lean.Expr.const `Bool []\n#eval check e1\n-- error: application type mismatch\n\n/--\n`let x : Int := Nat.zero; true`.\nIn general, the type of `let x := v; e`, if `e` does not reference `x`, is the type of `e`.\n-/\ndef e2 : Expr := .letE `x (.const ``Int []) (.const ``Nat.zero []) (.const ``true []) false\n#eval inferType e2\n-- Lean.Expr.const `Bool []\n#eval check e2\n-- error: invalid let declaration\n```\nHere is an example of a type-incorrect term that makes `inferType` fail:\n```lean\n/--\n`Nat.zero Nat.zero`\n-/\ndef e3 : Expr := .app (.const ``Nat.zero []) (.const ``Nat.zero [])\n#eval inferType e3\n-- error: function expected\n```\n\nSee `Lean.Meta.inferTypeImp` for the implementation of `inferType`.\n</code>",
 "174":
 "<code>createHypothesisGuarded (hypType hypProof : Expr) (hypName : Name := `h) : TacticM Unit</code>",
 "173":
 "<code class=\"docstring\">`assumption` tries to solve the main goal using a hypothesis of compatible type, or else fails.\nNote also the `‹t›` term notation, which is a shorthand for `show t by assumption`.\n</code>",
 "172": "<code>0 = 1</code>",
 "171":
 "<code>Eq.refl.{u_1} {α : Sort u_1} (a : α) : a = a</code><span class=\"sep\"></span><code class=\"docstring\">`Eq.refl a : a = a` is reflexivity, the unique constructor of the\nequality type. See also `rfl`, which is usually used instead. </code>",
 "170":
 "<code>Lean.Meta.mkAppM (constName : Name) (xs : Array Expr) : MetaM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Returns the application `constName xs`.\nIt tries to fill the implicit arguments before the last element in `xs`.\n\nRemark:\n``mkAppM `arbitrary #[α]`` returns `@arbitrary.{u} α` without synthesizing\nthe implicit argument occurring after `α`.\nGiven a `x : ([Decidable p] → Bool) × Nat`, ``mkAppM `Prod.fst #[x]``,\nreturns `@Prod.fst ([Decidable p] → Bool) Nat x`.\n</code>",
 "17":
 "<code class=\"docstring\">`for x in e do s`  iterates over `e` assuming `e`'s type has an instance of the `ForIn` typeclass.\n`break` and `continue` are supported inside `for` loops.\n`for x in e, x2 in e2, ... do s` iterates of the given collections in parallel,\nuntil at least one of them is exhausted.\nThe types of `e2` etc. must implement the `ToStream` typeclass.\n</code>",
 "169":
 "<code><span class=\"literal string\">\"create_bogus_hypothesis\"</span> : String</code>",
 "168":
 "<code><span class=\"literal string\">\"create_nat_hypothesis\"</span> : String</code>",
 "167":
 "<code>List.toArray.{u_1} {α : Type u_1} (xs : List α) : Array α</code><span class=\"sep\"></span><code class=\"docstring\">Converts a `List α` into an `Array α`.\n\n `O(|xs|)`. At runtime, this operation is implemented by `List.toArrayImpl` and takes time linear in\nthe length of the list. `List.toArray` should be used instead of `Array.mk`.\n\nExamples:\n * `[1, 2, 3].toArray = #[1, 2, 3]`\n * `[\"monday\", \"wednesday\", friday\"].toArray = #[\"monday\", \"wednesday\", friday\"].`\n</code>",
 "166":
 "<code>Lean.MVarId.assertHypotheses (mvarId : MVarId) (hs : Array Hypothesis) : MetaM (Array FVarId × MVarId)</code><span class=\"sep\"></span><code class=\"docstring\">Convert the given goal `Ctx |- target` into `Ctx, (hs[0].userName : hs[0].type) ... |-target`.\nIt assumes `hs[i].val` has type `hs[i].type`. </code>",
 "165": "<code>Expr</code>",
 "164": "<code>optParam Name `h</code>",
 "163": "<code>Lean.Meta.Hypothesis : Type</code>",
 "162": "<code>Hypothesis</code>",
 "161": "<code>optParam Name `h</code>",
 "160":
 "<code>createHypothesis (hypType hypProof : Expr) (hypName : Name := `h) : TacticM Unit</code>",
 "16": "<code>Lean.Elab.Tactic.getUnsolvedGoals : TacticM (List MVarId)</code>",
 "159":
 "<code><span class=\"literal string\">\"prove_goal\"</span> : String</code>",
 "158":
 "<code>Lean.Elab.Tactic.replaceMainGoal (mvarIds : List MVarId) : TacticM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Discard the first goal and replace it by the given list of goals,\nkeeping the other goals. This is used in conjunction with `getMainGoal`.\n\nContract: between `getMainGoal` and `replaceMainGoal`, nothing manipulates the goal list.\n\nSee also `Lean.Elab.Tactic.popMainGoal` and `Lean.Elab.Tactic.pushGoal`/`Lean.Elab.Tactic.pushGoal` for another interface.\n</code>",
 "157":
 "<code>Lean.MVarId.assign {m : Type → Type} [MonadMCtx m] (mvarId : MVarId) (val : Expr) : m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Add `mvarId := x` to the metavariable assignment.\nThis method does not check whether `mvarId` is already assigned, nor it checks whether\na cycle is being introduced, or whether the expression has the right type.\nThis is a low-level API, and it is safer to use `isDefEq (mkMVar mvarId) x`.\n</code>",
 "156": "<code>proveGoal (proof : Expr) : TacticM Unit</code>",
 "155": "<code>Nat.prime_two : Nat.Prime 2</code>",
 "154":
 "<code class=\"docstring\">`exact e` closes the main goal if its target type matches that of `e`.\n</code>",
 "153":
 "<code>Nat.Prime (p : ℕ) : Prop</code><span class=\"sep\"></span><code class=\"docstring\">`Nat.Prime p` means that `p` is a prime number, that is, a natural number\nat least 2 whose only divisors are `p` and `1`.\nThe theorem `Nat.prime_def` witnesses this description of a prime number. </code>",
 "152":
 "<code>Lean.Elab.Term.elabTerm (stx : Syntax) (expectedType? : Option Expr) (catchExPostpone implicitLambda : Bool := true) :\n  TermElabM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Main function for elaborating terms.\nIt extracts the elaboration methods from the environment using the node kind.\nRecall that the environment has a mapping from `SyntaxNodeKind` to `TermElab` methods.\nIt creates a fresh macro scope for executing the elaboration method.\nAll unlogged trace messages produced by the elaboration method are logged using\nthe position information at `stx`. If the elaboration method throws an `Exception.error` and `errToSorry == true`,\nthe error is logged and a synthetic sorry expression is returned.\nIf the elaboration throws `Exception.postpone` and `catchExPostpone == true`,\na new synthetic metavariable of kind `SyntheticMVarKind.postponed` is created, registered,\nand returned.\nThe option `catchExPostpone == false` is used to implement `resumeElabTerm`\nto prevent the creation of another synthetic metavariable when resuming the elaboration.\n\nIf `implicitLambda == false`, then disable implicit lambdas feature for the given syntax, but not for its subterms.\nWe use this flag to implement, for example, the `@` modifier. If `Context.implicitLambda == false`, then this parameter has no effect.\n</code>",
 "151":
 "<code><span class=\"literal string\">\"create_goal\"</span> : String</code>",
 "150":
 "<code>Lean.Meta.mkEq (a b : Expr) : MetaM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Returns `a = b`. </code>",
 "15": "<code>List MVarId</code>",
 "149":
 "<code><span class=\"literal string\">\"create_reflexivity_goal\"</span> : String</code>",
 "148":
 "<code class=\"docstring\">`use e₁, e₂, ⋯` is similar to `exists`, but unlike `exists` it is equivalent to applying the tactic\n`refine ⟨e₁, e₂, ⋯, ?_, ⋯, ?_⟩` with any number of placeholders (rather than just one) and\nthen trying to close goals associated to the placeholders with a configurable discharger (rather\nthan just `try trivial`).\n\nExamples:\n\n```lean\nexample : ∃ x : Nat, x = x := by use 42\n\nexample : ∃ x : Nat, ∃ y : Nat, x = y := by use 42, 42\n\nexample : ∃ x : String × String, x.1 = x.2 := by use (\"forty-two\", \"forty-two\")\n```\n\n`use! e₁, e₂, ⋯` is similar but it applies constructors everywhere rather than just for\ngoals that correspond to the last argument of a constructor. This gives the effect that\nnested constructors are being flattened out, with the supplied values being used along the\nleaves and nodes of the tree of constructors.\nWith `use!` one can feed in each `42` one at a time:\n\n```lean\nexample : ∃ p : Nat × Nat, p.1 = p.2 := by use! 42, 42\n\nexample : ∃ p : Nat × Nat, p.1 = p.2 := by use! (42, 42)\n```\n\nThe second line makes use of the fact that `use!` tries refining with the argument before\napplying a constructor. Also note that `use`/`use!` by default uses a tactic\ncalled `use_discharger` to discharge goals, so `use! 42` will close the goal in this example since\n`use_discharger` applies `rfl`, which as a consequence solves for the other `Nat` metavariable.\n\nThese tactics take an optional discharger to handle remaining explicit `Prop` constructor arguments.\nBy default it is `use (discharger := try with_reducible use_discharger) e₁, e₂, ⋯`.\nTo turn off the discharger and keep all goals, use `(discharger := skip)`.\nTo allow \"heavy refls\", use `(discharger := try use_discharger)`.\n</code>",
 "147":
 "<code><span class=\"literal string\">\"create_nat_goal\"</span> : String</code>",
 "146": "<code>Lean.Expr.mvarId! : Expr → MVarId</code>",
 "145":
 "<code>Lean.Elab.Tactic.appendGoals (mvarIds : List MVarId) : TacticM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Add the given goals at the end of the current list of goals. </code>",
 "144":
 "<code>Lean.Meta.mkFreshExprMVar (type? : Option Expr) (kind : MetavarKind := MetavarKind.natural)\n  (userName : Name := Name.anonymous) : MetaM Expr</code>",
 "143": "<code>createGoal (goalType : Expr) : TacticM Unit</code>",
 "142":
 "<code>Option.none.{u} {α : Type u} : Option α</code><span class=\"sep\"></span><code class=\"docstring\">No value. </code>",
 "141":
 "<code>Option.some.{u} {α : Type u} (val : α) : Option α</code><span class=\"sep\"></span><code class=\"docstring\">Some value of type `α`. </code>",
 "140":
 "<code class=\"docstring\">`return` used outside of `do` blocks creates an implicit block around it\nand thus is equivalent to `pure e`, but helps with avoiding parentheses.\n</code>",
 "14":
 "<code><span class=\"literal string\">\"print_goals\"</span> : String</code>",
 "139":
 "<code>List.findM?.{u} {m : Type → Type u} [Monad m] {α : Type} (p : α → m Bool) : List α → m (Option α)</code><span class=\"sep\"></span><code class=\"docstring\">Returns the first element of the list for which the monadic predicate `p` returns `true`, or `none`\nif no such element is found. Elements of the list are checked in order.\n\n`O(|l|)`.\n\nExample:\n```lean example\n#eval [7, 6, 5, 8, 1, 2, 6].findM? fun i =&gt; do\n  if i &lt; 5 then\n    return true\n  if i ≤ 6 then\n    IO.println s!\"Almost! {i}\"\n  return false\n```\n```output\nAlmost! 6\nAlmost! 5\n```\n```output\nsome 1\n```\n</code>",
 "138": "<code>Option LocalDecl</code>",
 "137":
 "<code><span class=\"literal string\">\"assump''\"</span> : String</code>",
 "136":
 "<code><span class=\"literal string\">\"assump'\"</span> : String</code>",
 "135":
 "<code>Lean.ToExpr.toExpr.{u} {α : Type u} [self : ToExpr α] : α → Expr</code><span class=\"sep\"></span><code class=\"docstring\">Convert a value `a : α` into an expression that denotes `a` </code>",
 "134":
 "<code>Lean.Expr.const (declName : Name) (us : List Level) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">A (universe polymorphic) constant that has been defined earlier in the module or\nby another imported module. For example, `@Eq.{1}` is represented\nas ``Expr.const `Eq [.succ .zero]``, and `@Array.map.{0, 0}` is represented\nas ``Expr.const `Array.map [.zero, .zero]``.\n</code>",
 "133": "<code>Lean.LocalDecl.toExpr (decl : LocalDecl) : Expr</code>",
 "132":
 "<code>Lean.Elab.Tactic.closeMainGoal (tacName : Name) (val : Expr) (checkUnassigned : Bool := true) : TacticM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Closes main goal using the given expression.\nIf `checkUnassigned == true`, then `val` must not contain unassigned metavariables.\nReturns `true` if `val` was successfully used to close the goal.\n</code>",
 "131":
 "<code>Lean.MetavarDecl.type (self : MetavarDecl) : Expr</code><span class=\"sep\"></span><code class=\"docstring\">The type of the metavarible, in the given `lctx`. </code>",
 "130":
 "<code>Lean.Meta.isDefEq (t s : Expr) : MetaM Bool</code><span class=\"sep\"></span><code class=\"docstring\">Determines whether two expressions are definitionally equal to each other.\n\nTo control how metavariables are assigned and unified, metavariables and their context have a \"depth\".\nGiven a metavariable `?m` and a `MetavarContext` `mctx`, `?m` is not assigned if `?m.depth != mctx.depth`.\nThe combinator `withNewMCtxDepth x` will bump the depth while executing `x`.\nSo, `withNewMCtxDepth (isDefEq a b)` is `isDefEq` without any mvar assignment happening\nwhereas `isDefEq a b` will assign any metavariables of the current depth in `a` and `b` to unify them.\n\nFor matching (where only mvars in `b` should be assigned), we create the term inside the `withNewMCtxDepth`.\nFor an example, see [Lean.Meta.Simp.tryTheoremWithExtraArgs?](https://github.com/leanprover/lean4/blob/master/src/Lean/Meta/Tactic/Simp/Rewrite.lean#L100-L106)\n</code>",
 "13":
 "<code>Eq.{u_1} {α : Sort u_1} : α → α → Prop</code><span class=\"sep\"></span><code class=\"docstring\">The equality relation. It has one introduction rule, `Eq.refl`.\nWe use `a = b` as notation for `Eq a b`.\nA fundamental property of equality is that it is an equivalence relation.\n```\nvariable (α : Type) (a b c d : α)\nvariable (hab : a = b) (hcb : c = b) (hcd : c = d)\n\nexample : a = d :=\n  Eq.trans (Eq.trans hab (Eq.symm hcb)) hcd\n```\nEquality is much more than an equivalence relation, however. It has the important property that every assertion\nrespects the equivalence, in the sense that we can substitute equal expressions without changing the truth value.\nThat is, given `h1 : a = b` and `h2 : p a`, we can construct a proof for `p b` using substitution: `Eq.subst h1 h2`.\nExample:\n```\nexample (α : Type) (a b : α) (p : α → Prop)\n        (h1 : a = b) (h2 : p a) : p b :=\n  Eq.subst h1 h2\n\nexample (α : Type) (a b : α) (p : α → Prop)\n    (h1 : a = b) (h2 : p a) : p b :=\n  h1 ▸ h2\n```\nThe triangle in the second presentation is a macro built on top of `Eq.subst` and `Eq.symm`, and you can enter it by typing `\\t`.\nFor more information: [Equality](https://lean-lang.org/theorem_proving_in_lean4/quantifiers_and_equality.html#equality)\n\n\nConventions for notations in identifiers:\n\n * The recommended spelling of `=` in identifiers is `eq`.</code>",
 "129": "<code>MetavarDecl</code>",
 "128":
 "<code><span class=\"literal string\">\"assump\"</span> : String</code>",
 "127":
 "<code>Lean.Elab.Tactic.getMainTarget : TacticM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Return expected type for the main goal. </code>",
 "126":
 "<code>getGoalType : TacticM Expr</code><span class=\"sep\"></span><code class=\"docstring\">Tactic to return goal expression (the type) </code>",
 "125":
 "<code>Lean.Elab.Tactic.getMainDecl : TacticM MetavarDecl</code><span class=\"sep\"></span><code class=\"docstring\">Return the main goal metavariable declaration. </code>",
 "124":
 "<code>Lean.MetavarDecl : Type</code><span class=\"sep\"></span><code class=\"docstring\">Information about a metavariable. </code>",
 "123":
 "<code>getGoalDecl : TacticM MetavarDecl</code><span class=\"sep\"></span><code class=\"docstring\">Tactic to return goal declaration</code>",
 "122":
 "<code>Lean.MVarId : Type</code><span class=\"sep\"></span><code class=\"docstring\">Universe metavariable Id   </code>",
 "121":
 "<code>getGoalVar : TacticM MVarId</code><span class=\"sep\"></span><code class=\"docstring\">Tactic to return goal variable </code>",
 "120":
 "<code><span class=\"literal string\">\"Hyp types:\"</span> : String</code>",
 "12":
 "<code>HAdd.hAdd.{u, v, w} {α : Type u} {β : Type v} {γ : outParam (Type w)} [self : HAdd α β γ] : α → β → γ</code><span class=\"sep\"></span><code class=\"docstring\">`a + b` computes the sum of `a` and `b`.\nThe meaning of this notation is type-dependent. \n\nConventions for notations in identifiers:\n\n * The recommended spelling of `+` in identifiers is `add`.</code>",
 "119": "<code>List Expr</code>",
 "118":
 "<code><span class=\"literal string\">\"print_hypotheses_types\"</span> : String</code>",
 "117":
 "<code>List.map.{u, v} {α : Type u} {β : Type v} (f : α → β) (l : List α) : List β</code><span class=\"sep\"></span><code class=\"docstring\">Applies a function to each element of the list, returning the resulting list of values.\n\n`O(|l|)`.\n\nExamples:\n* `[a, b, c].map f = [f a, f b, f c]`\n* `[].map Nat.succ = []`\n* `[\"one\", \"two\", \"three\"].map (·.length) = [3, 3, 5]`\n* `[\"one\", \"two\", \"three\"].map (·.reverse) = [\"eno\", \"owt\", \"eerht\"]`\n</code>",
 "116":
 "<code>Lean.Expr : Type</code><span class=\"sep\"></span><code class=\"docstring\">Lean expressions. This data structure is used in the kernel and\nelaborator. However, expressions sent to the kernel should not\ncontain metavariables.\n\nRemark: we use the `E` suffix (short for `Expr`) to avoid collision with keywords.\nWe considered using «...», but it is too inconvenient to use.\n</code>",
 "115": "<code>getHypothesesTypes : TacticM (List Expr)</code>",
 "114": "<code>List LocalDecl</code>",
 "113":
 "<code>List.{u} (α : Type u) : Type u</code><span class=\"sep\"></span><code class=\"docstring\">Linked lists: ordered lists, in which each element has a reference to the next element.\n\nMost operations on linked lists take time proportional to the length of the list, because each\nelement must be traversed to find the next element.\n\n`List α` is isomorphic to `Array α`, but they are useful for different things:\n* `List α` is easier for reasoning, and `Array α` is modeled as a wrapper around `List α`.\n* `List α` works well as a persistent data structure, when many copies of the tail are shared. When\n  the value is not shared, `Array α` will have better performance because it can do destructive\n  updates.\n</code>",
 "112": "<code>getHypotheses : TacticM (List LocalDecl)</code>",
 "111":
 "<code>lookIntoEnvironment' : TacticM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Check the context for a theorem named `riemannHypothesis`. </code>",
 "110":
 "<code class=\"docstring\">`#eval e` evaluates the expression `e` by compiling and evaluating it.\n\n* The command attempts to use `ToExpr`, `Repr`, or `ToString` instances to print the result.\n* If `e` is a monadic value of type `m ty`, then the command tries to adapt the monad `m`\n  to one of the monads that `#eval` supports, which include `IO`, `CoreM`, `MetaM`, `TermElabM`, and `CommandElabM`.\n  Users can define `MonadEval` instances to extend the list of supported monads.\n\nThe `#eval` command gracefully degrades in capability depending on what is imported.\nImporting the `Lean.Elab.Command` module provides full capabilities.\n\nDue to unsoundness, `#eval` refuses to evaluate expressions that depend on `sorry`, even indirectly,\nsince the presence of `sorry` can lead to runtime instability and crashes.\nThis check can be overridden with the `#eval! e` command.\n\nOptions:\n* If `eval.pp` is true (default: true) then tries to use `ToExpr` instances to make use of the\n  usual pretty printer. Otherwise, only tries using `Repr` and `ToString` instances.\n* If `eval.type` is true (default: false) then pretty prints the type of the evaluated value.\n* If `eval.derive.repr` is true (default: true) then attempts to auto-derive a `Repr` instance\n  when there is no other way to print the result.\n\nSee also: `#reduce e` for evaluation by term reduction.\n</code>",
 "11": "<code>ℕ</code>",
 "109":
 "<code>Lean.Environment.contains (env : Environment) (n : Name) (skipRealize : Bool := true) : Bool</code><span class=\"sep\"></span><code class=\"docstring\">Checks whether `findAsync?` would return a result.\n\nNOTE: Unlike `findAsync`, this function defaults `skipRealize` to `true` to avoid unnecessary\nblocking on realizations, which should always be brought into scope by running `realizeConst`, which\ndoes its own, optimized existence check.\n</code>",
 "108":
 "<code class=\"docstring\">`dbg_trace e` prints `e` (which can be an interpolated string literal) to stderr.\nIt should only be used for debugging.\n</code>",
 "107":
 "<code>Lean.MonadEnv.getEnv {m : Type → Type} [self : MonadEnv m] : m Environment</code>",
 "106": "<code>Environment</code>",
 "105":
 "<code>lookIntoEnvironment : MetaM Unit</code><span class=\"sep\"></span><code class=\"docstring\">Check the context for a theorem named `riemannHypothesis`. </code>",
 "104": "<code>?m.11847</code>",
 "103":
 "<code>Lean.Meta.MetaM (α : Type) : Type</code><span class=\"sep\"></span><code class=\"docstring\">The `MetaM` monad is a core component of Lean's metaprogramming framework, facilitating the\nconstruction and manipulation of expressions (`Lean.Expr`) within Lean.\n\nIt builds on top of `CoreM` and additionally provides:\n- A `LocalContext` for managing free variables.\n- A `MetavarContext` for managing metavariables.\n- A `Cache` for caching results of the key `MetaM` operations.\n\nThe key operations provided by `MetaM` are:\n- `inferType`, which attempts to automatically infer the type of a given expression.\n- `whnf`, which reduces an expression to the point where the outermost part is no longer reducible\n  but the inside may still contain unreduced expression.\n- `isDefEq`, which determines whether two expressions are definitionally equal, possibly assigning\n  meta variables in the process.\n- `forallTelescope` and `lambdaTelescope`, which make it possible to automatically move into\n  (nested) binders while updating the local context.\n\nThe following is a small example that demonstrates how to obtain and manipulate the type of a\n`Fin` expression:\n```\nimport Lean\n\nopen Lean Meta\n\ndef getFinBound (e : Expr) : MetaM (Option Expr) := do\n  let type ← whnf (← inferType e)\n  let_expr Fin bound := type | return none\n  return bound\n\ndef a : Fin 100 := 42\n\nrun_meta\n  match ← getFinBound (.const ``a []) with\n  | some limit =&gt; IO.println (← ppExpr limit)\n  | none =&gt; IO.println \"no limit found\"\n```\n</code>",
 "102": "<code>printHypotheses' : MetaM Unit</code>",
 "101": "<code>2 + 2 = 4</code>",
 "100": "<code>1 + 1 = 2</code>",
 "10":
 "<code>Lean.logInfo {m : Type → Type} [Monad m] [MonadLog m] [AddMessageContext m] [MonadOptions m] (msgData : MessageData) :\n  m Unit</code><span class=\"sep\"></span><code class=\"docstring\">Log a new information message using the given message data. The position is provided by `getRef`. </code>",
 "1":
 "<code><span class=\"literal string\">\"do_nothing\"</span> : String</code>",
 "0":
 "<code class=\"docstring\">Makes names from other namespaces visible without writing the namespace prefix.\n\nNames that are made available with `open` are visible within the current `section` or `namespace`\nblock. This makes referring to (type) definitions and theorems easier, but note that it can also\nmake [scoped instances], notations, and attributes from a different namespace available.\n\nThe `open` command can be used in a few different ways:\n\n* `open Some.Namespace.Path1 Some.Namespace.Path2` makes all non-protected names in\n  `Some.Namespace.Path1` and `Some.Namespace.Path2` available without the prefix, so that\n  `Some.Namespace.Path1.x` and `Some.Namespace.Path2.y` can be referred to by writing only `x` and\n  `y`.\n\n* `open Some.Namespace.Path hiding def1 def2` opens all non-protected names in `Some.Namespace.Path`\n  except `def1` and `def2`.\n\n* `open Some.Namespace.Path (def1 def2)` only makes `Some.Namespace.Path.def1` and\n  `Some.Namespace.Path.def2` available without the full prefix, so `Some.Namespace.Path.def3` would\n  be unaffected.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open Some.Namespace.Path renaming def1 → def1', def2 → def2'` same as `open Some.Namespace.Path\n  (def1 def2)` but `def1`/`def2`'s names are changed to `def1'`/`def2'`.\n\n  This works even if `def1` and `def2` are `protected`.\n\n* `open scoped Some.Namespace.Path1 Some.Namespace.Path2` **only** opens [scoped instances],\n  notations, and attributes from `Namespace1` and `Namespace2`; it does **not** make any other name\n  available.\n\n* `open &lt;any of the open shapes above&gt; in` makes the names `open`-ed visible only in the next\n  command or expression.\n\n[scoped instance]: https://lean-lang.org/theorem_proving_in_lean4/type_classes.html#scoped-instances\n(Scoped instances in Theorem Proving in Lean)\n\n\n## Examples\n\n```lean\n/-- SKI combinators https://en.wikipedia.org/wiki/SKI_combinator_calculus -/\nnamespace Combinator.Calculus\n  def I (a : α) : α := a\n  def K (a : α) : β → α := fun _ =&gt; a\n  def S (x : α → β → γ) (y : α → β) (z : α) : γ := x z (y z)\nend Combinator.Calculus\n\nsection\n  -- open everything under `Combinator.Calculus`, *i.e.* `I`, `K` and `S`,\n  -- until the section ends\n  open Combinator.Calculus\n\n  theorem SKx_eq_K : S K x = I := rfl\nend\n\n-- open everything under `Combinator.Calculus` only for the next command (the next `theorem`, here)\nopen Combinator.Calculus in\ntheorem SKx_eq_K' : S K x = I := rfl\n\nsection\n  -- open only `S` and `K` under `Combinator.Calculus`\n  open Combinator.Calculus (S K)\n\n  theorem SKxy_eq_y : S K x y = y := rfl\n\n  -- `I` is not in scope, we have to use its full path\n  theorem SKxy_eq_Iy : S K x y = Combinator.Calculus.I y := rfl\nend\n\nsection\n  open Combinator.Calculus\n    renaming\n      I → identity,\n      K → konstant\n\n  #check identity\n  #check konstant\nend\n\nsection\n  open Combinator.Calculus\n    hiding S\n\n  #check I\n  #check K\nend\n\nsection\n  namespace Demo\n    inductive MyType\n    | val\n\n    namespace N1\n      scoped infix:68 \" ≋ \" =&gt; BEq.beq\n\n      scoped instance : BEq MyType where\n        beq _ _ := true\n\n      def Alias := MyType\n    end N1\n  end Demo\n\n  -- bring `≋` and the instance in scope, but not `Alias`\n  open scoped Demo.N1\n\n  #check Demo.MyType.val == Demo.MyType.val\n  #check Demo.MyType.val ≋ Demo.MyType.val\n  -- #check Alias -- unknown identifier 'Alias'\nend\n```\n</code>"}