<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Comparing Goals and Hypotheses — Hands-on Lean 4 Tactic Writing</title><style>


.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}


</style>
<script>
      

window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}

</script>
    
<script>
      
document.addEventListener("DOMContentLoaded", () => {
    for (const m of document.querySelectorAll(".math.inline")) {
        katex.render(m.textContent, m, {throwOnError: false, displayMode: false});
    }
    for (const m of document.querySelectorAll(".math.display")) {
        katex.render(m.textContent, m, {throwOnError: false, displayMode: true});
    }
});
</script>
    
<script src="../-verso-js/popper.js"></script>
    <script src="../-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="../-verso-css/tippy-border.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <link rel="icon" type="image/x-icon" href="../static/img/favicon.ico">
    <link rel="stylesheet" href="../static/style.css">
    <link rel="stylesheet" href="../static/navbar.css">
    <link rel="stylesheet" href="../static/navbar-colors.css">
    <script crossorigin="anonymous" src="https://code.jquery.com/jquery-2.2.4.js"></script>
    <script src="../static/build-nav.js"></script>
    <script>
      window.onload=function(){buildNav();}</script>
    </head>
  <body>
    <header>
      <div class="inner-wrap">
        <a class="logo" href="../">Hands-on Lean 4 Tactic Writing</a><nav class="top" role="navigation">
          <ol>
            <li>
              <a href="../Introduction">Introduction</a></li>
            <li>
              <a href="../Reading-and-Changing-the-Goal">Reading and Changing the Goal</a></li>
            <li>
              <a href="../Reading-and-Changing-the-Hypotheses">Reading and Changing the Hypotheses</a></li>
            <li>
              <a href="../Comparing-Goals-and-Hypotheses">Comparing Goals and Hypotheses</a></li>
            <li>
              <a href="../Adding-Goals-and-Hypotheses">Adding Goals and Hypotheses</a></li>
            <li>
              <a href="../Manipulating-Expressions">Manipulating Expressions</a></li>
            <li>
              <a href="../Manipulating-Subexpressions">Manipulating Subexpressions</a></li>
            <li>
              <a href="../Final-Project-Autogeneralize">Final Project: The Autogeneralize Tactic</a></li>
            </ol>
          </nav>
        </div>
      </header>
    <div class="main" role="main">
      <div class="wrap">
        <h1>
          Comparing Goals and Hypotheses</h1>
        <p>
          By the end of this section, you will have built an <code>assumption</code> tactic that compares hypotheses of a theorem to its goal, and proves the theorem if any hypothesis exactly matches the goal.</p>
        <section>
          <h2>
            Getting Hypotheses as Declarations</h2>
          <p>
            We know how to print hypotheses.</p>
          <p>
            But suppose we actually want to save the hypotheses, not just print them out, so we can see if any match the goal?</p>
          <p>
            Let's do that now.</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-635" data-verso-hover="0">open</span> <span class="unknown token" data-binding="">Lean</span> <span class="unknown token" data-binding="">Elab</span> <span class="unknown token" data-binding="">Meta</span> <span class="unknown token" data-binding="">Tactic</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-663">def</span> <span class="const token" data-binding="const-getHypotheses" data-verso-hover="112">getHypotheses</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="113">List</span> <span class="const token" data-binding="const-Lean.LocalDecl" data-verso-hover="87">LocalDecl</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-711">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-716">let</span> <span class="keyword token" data-binding="kw-occ-null-720">mut</span> <span class="var token" data-binding="var-_uniq.626" data-verso-hover="114">hypotheses</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-List" data-verso-hover="113">List</span> <span class="const token" data-binding="const-Lean.LocalDecl" data-verso-hover="87">LocalDecl</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-760">let</span> <span class="var token" data-binding="var-_uniq.57" data-verso-hover="8">goal</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainGoal" data-verso-hover="9">getMainGoal</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-787" data-verso-hover="17">for</span> <span class="var token" data-binding="var-_uniq.335" data-verso-hover="61">ldecl</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-791">in</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="var token" data-binding="var-_uniq.57" data-verso-hover="8">goal</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.MVarId.getDecl" data-verso-hover="78">getDecl</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.MetavarDecl.lctx" data-verso-hover="79">lctx</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-787" data-verso-hover="17">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-831">if</span> <span class="var token" data-binding="var-_uniq.335" data-verso-hover="61">ldecl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.isImplementationDetail" data-verso-hover="63">isImplementationDetail</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-831">then</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doContinue-868" data-verso-hover="64">continue</span>
    <span class="var token" data-binding="var-_uniq.626" data-verso-hover="114">hypotheses</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.335" data-verso-hover="61">ldecl</span> <span class="unknown token" data-binding="">::</span> <span class="var token" data-binding="var-_uniq.626" data-verso-hover="114">hypotheses</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-917" data-verso-hover="3">return</span> <span class="var token" data-binding="var-_uniq.626" data-verso-hover="114">hypotheses</span>
<span class="unknown token" data-binding=""></span></code><p>
            Note that instead of returning a <code>Unit</code>, we return a <code>List LocalDecl</code>.</p>
          <p>
            And we wrap it all up in the <code>TacticM</code> monad so we can access the goal.</p>
          </section>
        <section>
          <h2>
            Getting Hypotheses as Expressions</h2>
          <p>
            The actual human-readable part of the hypothesis isn’t its declaration, though.</p>
          <p>
            It’s the <em>type</em> of the hypothesis.</p>
          <p>
            So, let’s write a method to get that.</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-1303">def</span> <span class="const token" data-binding="const-getHypothesesTypes" data-verso-hover="115">getHypothesesTypes</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-List" data-verso-hover="113">List</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-1351">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-1356" data-verso-hover="3">return</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getHypotheses" data-verso-hover="112">getHypotheses</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.map" data-verso-hover="117">map</span> <span class="unknown token" data-binding="">(</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-1393">fun</span> <span class="var token" data-binding="var-_uniq.915" data-verso-hover="61">hypothesis</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="var token" data-binding="var-_uniq.915" data-verso-hover="61">hypothesis</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span>
  <span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-1432">elab</span> <span class="literal string token" data-binding="" data-verso-hover="118">"print_hypotheses_types"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-1474">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-1479">let</span> <span class="var token" data-binding="var-_uniq.1076" data-verso-hover="119">types</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getHypothesesTypes" data-verso-hover="115">getHypothesesTypes</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="10">logInfo</span> <span class="unknown token" data-binding="">(</span><span class="literal string token" data-binding="" data-verso-hover="120">"Hyp types:"</span> <span class="unknown token" data-binding="">++</span> <span class="var token" data-binding="var-_uniq.1076" data-verso-hover="119">types</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
            Now if we test it out…</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-1596">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span> <span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">ℕ</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2242" data-verso-hover="70">h1</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2269" data-verso-hover="71">h2</span><span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="11">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span><span class="unknown token" data-binding="">+</span><span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span><span class="unknown token" data-binding="">=</span><span class="typed token" data-binding="" data-verso-hover="11">5</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5771804059093529830-1652-1654"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1652" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5771804059093529830-1652-1654"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="72">ℕ</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="72">ℕ</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2242" data-verso-hover="70">h1</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span><span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>2</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2269" data-verso-hover="71">h2</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span><span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span><span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span><span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>5</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5771804059093529830-1657-1679"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">'print_hypotheses_types' tactic does nothing
note: this linter can be disabled with `set_option linter.unusedTactic false`</code><code class="message info">Hyp types:[b = 3, a = 2, ℕ, ℕ]</code></span></span><span class="keyword token" data-binding="kw-occ-tacticPrint_hypotheses_types-1657">print_hypotheses_types</span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5771804059093529830-1657-1679"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="72">ℕ</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="72">ℕ</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2242" data-verso-hover="70">h1</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span><span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>2</span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.2269" data-verso-hover="71">h2</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span><span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.2209" data-verso-hover="11">a</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span><span class="var token" data-binding="var-_uniq.2211" data-verso-hover="11">b</span><span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>5</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-1682-1695"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-1682" data-verso-hover="37">simp</span> <span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.2242" data-verso-hover="70">h1</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.2269" data-verso-hover="71">h2</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-1682-1695"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
            …we see that this tactic get us the relevant, human-readable information about hypotheses.</p>
          <p>
            Notice that <code>getHypothesesTypes</code> returns <code>List Expr</code>.  All of the actual mathematical expressions in Lean need to be in type <code>Expr</code> to be manipulated.</p>
          </section>
        <section>
          <h2>
            Getting Goals as Declarations & Expressions</h2>
          <p>
            Now how do we get the human-readable part of the goal?  That’s the goal <em>type</em>, and we can access it using <code>getGoalType</code> below.</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="doc-comment token" data-binding="">/--  Tactic to return goal variable -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2184">def</span> <span class="const token" data-binding="const-getGoalVar" data-verso-hover="121">getGoalVar</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="const token" data-binding="const-Lean.MVarId" data-verso-hover="122">MVarId</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-2219">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-2224" data-verso-hover="3">return</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainGoal" data-verso-hover="9">getMainGoal</span>

<span class="doc-comment token" data-binding="">/--  Tactic to return goal declaration-/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2289">def</span> <span class="const token" data-binding="const-getGoalDecl" data-verso-hover="123">getGoalDecl</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="const token" data-binding="const-Lean.MetavarDecl" data-verso-hover="124">MetavarDecl</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-2330">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-2335" data-verso-hover="3">return</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainDecl" data-verso-hover="125">getMainDecl</span> -- (← getGoalVar).getDecl

<span class="doc-comment token" data-binding="">/--  Tactic to return goal expression (the type) -/</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2439">def</span> <span class="const token" data-binding="const-getGoalType" data-verso-hover="126">getGoalType</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span> <span class="unknown token" data-binding="">:=</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-2473">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-2478" data-verso-hover="3">return</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainTarget" data-verso-hover="127">getMainTarget</span>
  -- or (← getGoalDecl).type
  -- or (← getGoalVar).getType
<span class="unknown token" data-binding=""></span></code><p>
            Note that there were three “layers” we had to peel back to get to the relevant information about the goal:</p>
          <ul>
            <li>
              <p>
                Running <code>← getMainGoal</code> gets you the <strong>metavariable</strong> pointing to the goal (just a variable name and a pointer)…</p>
              </li>
            <li>
              <p>
                …then running <code>getDecl</code> on the metavariable gets you the <strong>declaration</strong> (the object that actually contains lots of information about the goal)…</p>
              </li>
            <li>
              <p>
                then running <code>type</code> on the declaration gets you the <strong>expression</strong> (the thing that actually contains relevant, human-readable information about the goal e.g. the expression <code>1+1=2</code>).</p>
              </li>
            </ul>
          <p>
            The <code>getMainTarget</code> function conveniently performs this sequence of operations in one go.</p>
          </section>
        <section>
          <h2>
            Comparing Hypotheses and Goals in the <code>assumption</code> Tactic</h2>
          <p>
            Finally, using the functions we made to read the goal and hypothesis, we are able to make an <code>assumption</code> tactic (example taken from the <a href="https://github.com/leanprover-community/lean4-metaprogramming-book">Lean 4 Metaprogramming Book</a>).</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-3548">elab</span> <span class="literal string token" data-binding="" data-verso-hover="128">"assump"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-3574">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-3579">let</span> <span class="var token" data-binding="var-_uniq.2868" data-verso-hover="129">goal_decl</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getGoalDecl" data-verso-hover="123">getGoalDecl</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-3611" data-verso-hover="17">for</span> <span class="var token" data-binding="var-_uniq.3009" data-verso-hover="61">hyp_decl</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-3615">in</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getHypotheses" data-verso-hover="112">getHypotheses</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-3611" data-verso-hover="17">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-3652">if</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="var token" data-binding="var-_uniq.3009" data-verso-hover="61">hyp_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span> <span class="var token" data-binding="var-_uniq.2868" data-verso-hover="129">goal_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.MetavarDecl.type" data-verso-hover="131">type</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-3652">then</span>
      <span class="const token" data-binding="const-Lean.Elab.Tactic.closeMainGoal" data-verso-hover="132">closeMainGoal</span> <span class="unknown token" data-binding="">`assump</span> <span class="var token" data-binding="var-_uniq.3009" data-verso-hover="61">hyp_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.toExpr" data-verso-hover="133">toExpr</span>
<span class="unknown token" data-binding=""></span></code><p>
            We find our function closes the goal when the conclusion is in the hypothesis, and does nothing if not.  Just as expected!</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-3893">example</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3831" data-verso-hover="27">P</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="28">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3833" data-verso-hover="45">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3831" data-verso-hover="27">P</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3831" data-verso-hover="27">P</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-3027895528727637923-3926-3928"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3926" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3027895528727637923-3926-3928"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3831" data-verso-hover="27">P</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="28">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3833" data-verso-hover="45">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.3831" data-verso-hover="27">P</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.3831" data-verso-hover="27">P</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-3931-3937"><span class="keyword token" data-binding="kw-occ-tacticAssump-3931">assump</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3931-3937"><span class="tactic-state">All goals completed! 🐙</span></span> -- works

<span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-3948">example</span></span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.3842" data-verso-hover="27">P</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="28">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.3842" data-verso-hover="27">P</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-13069201774810181833-3974-3976"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3974" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13069201774810181833-3974-3976"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3842" data-verso-hover="27">P</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="28">Prop</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.3842" data-verso-hover="27">P</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-13069201774810181833-3979-3985"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">'assump' tactic does nothing
note: this linter can be disabled with `set_option linter.unusedTactic false`</code></span></span><span class="keyword token" data-binding="kw-occ-tacticAssump-3979">assump</span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13069201774810181833-3979-3985"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.3842" data-verso-hover="27">P</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="28">Prop</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.3842" data-verso-hover="27">P</span></span></span></span></span></span> -- does nothing
  <span class="tactic"><label for="tactic-state-7-4004-4009"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-4004" data-verso-hover="42">sorry</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-4004-4009"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
            Notice that when we <code>closeMainGoal</code> we need to pass it the expression <code>hyp_decl.toExpr</code> (the proof of the hypothesis) rather than the expression <code>hyp_decl.type</code> (the statement of the hypothesis).    They’re both expressions, but only the proof works as an argument to <code>closeMainGoal</code>.</p>
          <p>
            In this example:</p>
          <ul>
            <li>
              <p>
                <code>hyp_decl.toExpr</code> is the expression “p” (the “proof” of the proposition P)</p>
              </li>
            <li>
              <p>
                <code>hyp_decl.type</code> is the expression “P” (the proposition P.)</p>
              </li>
            </ul>
          <p>
            In other words, we need to close the main goal with <code>hyp_decl.toExpr</code>  because we actually need the <em>term</em> (the proof of P), rather than the <em>type</em> (the proposition P).</p>
          </section>
        <section>
          <h2>
            Comparing <code>isDefEq</code> and <code>==</code></h2>
          <p>
            In the <code>assumption</code> tactic, why did we use <code>isDefEq</code> instead of <code>==</code>?  That is, we used:</p>
          <ul>
            <li>
              <p>
                <code>isDefEq hyp_decl.type goal_decl.type</code> instead of</p>
              </li>
            <li>
              <p>
                <code>hyp_decl.type == goal_decl.type</code></p>
              </li>
            </ul>
          <p>
            Well sometimes two Lean expressions may seem the same to us...</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Expr.const `Nat.zero []</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4936" data-verso-hover="110">#eval</span></span> <span class="const token" data-binding="const-Lean.Expr.const" data-verso-hover="134">Expr.const</span> <span class="unknown token" data-binding="">`Nat.zero</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
<span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">(((Expr.const `OfNat.ofNat [Level.zero]).app (Expr.const `Nat [])).app (Expr.lit (Literal.natVal 0))).app
  ((Expr.const `instOfNatNat []).app (Expr.lit (Literal.natVal 0)))</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-4966" data-verso-hover="110">#eval</span></span> <span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span>
<span class="unknown token" data-binding=""></span></code><p>
            ......but  <code>==</code> will say things aren't equal.</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">false</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-5053" data-verso-hover="110">#eval</span></span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">==</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Expr.const" data-verso-hover="134">Expr.const</span> <span class="unknown token" data-binding="">`Nat.zero</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> -- false
<span class="unknown token" data-binding=""></span></code><p>
            However, Lean <code>isDefEq</code> will be more reasonable.</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">true</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.eval-5182" data-verso-hover="110">#eval</span></span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Expr.const" data-verso-hover="134">Expr.const</span> <span class="unknown token" data-binding="">`Nat.zero</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span> -- true
<span class="unknown token" data-binding=""></span></code><p>
            What's going on?</p>
          <p>
            Whenever there are metavariables (or "holes") in an expression, <code>isDefEq</code> tries to fill in the holes in the way that makes the expressions equal.</p>
          <ul>
            <li>
              <p>
                If it can, it outputs <code>true</code>.</p>
              </li>
            <li>
              <p>
                If there's no way to fill in metavariables to make the expressions equal, it outputs fals.</p>
              </li>
            </ul>
          <p>
            In this sense, <code>isDefEq</code> is a more generous, coarser notion of equality.  But we discuss it more in the next chapter.</p>
          </section>
        <section>
          <h2>
            Throwing Errors</h2>
          <p>
            Currently, if there are no matching assumptions, the <code>assump</code> tactic silently fails, by not changing the proof state.</p>
          <p>
            We can make a more elaborate version of this tactic by having it throw an error if there are no matching assumptions.</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-5933">elab</span> <span class="literal string token" data-binding="" data-verso-hover="136">"assump'"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-5960">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-5965">let</span> <span class="var token" data-binding="var-_uniq.4687" data-verso-hover="129">goal_decl</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getGoalDecl" data-verso-hover="123">getGoalDecl</span>

  -- check if any of the hypotheses matches the goal.
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-6052" data-verso-hover="17">for</span> <span class="var token" data-binding="var-_uniq.4838" data-verso-hover="61">hyp_decl</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doForDecl-6056">in</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getHypotheses" data-verso-hover="112">getHypotheses</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doFor-6052" data-verso-hover="17">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-6093">if</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="var token" data-binding="var-_uniq.4838" data-verso-hover="61">hyp_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span> <span class="var token" data-binding="var-_uniq.4687" data-verso-hover="129">goal_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.MetavarDecl.type" data-verso-hover="131">type</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doIf-6093">then</span>
      <span class="const token" data-binding="const-Lean.Elab.Tactic.closeMainGoal" data-verso-hover="132">closeMainGoal</span> <span class="unknown token" data-binding="">`assump'</span> <span class="var token" data-binding="var-_uniq.4838" data-verso-hover="61">hyp_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.toExpr" data-verso-hover="133">toExpr</span>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-6193" data-verso-hover="3">return</span>

  -- if no hypothesis matched, this tactic fails.
  <span class="keyword token" data-binding="kw-occ-Lean.termThrowError__-6253" data-verso-hover="88">throwError</span> <span class="unknown token" data-binding="">"No matching assumptions."</span>
<span class="unknown token" data-binding=""></span></code><p>
            Now, if we test it out…</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-6354">example</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6229" data-verso-hover="27">P</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="28">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.6231" data-verso-hover="45">p</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6229" data-verso-hover="27">P</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6229" data-verso-hover="27">P</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-2202290804586987840-6387-6389"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6387" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2202290804586987840-6387-6389"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6229" data-verso-hover="27">P</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="28">Prop</span></span></span><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6231" data-verso-hover="45">p</span></span><span class="colon">:</span><span class="type"><span class="var token" data-binding="var-_uniq.6229" data-verso-hover="27">P</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.6229" data-verso-hover="27">P</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-6392-6399"><span class="keyword token" data-binding="kw-occ-tacticAssump'-6392">assump'</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-6392-6399"><span class="tactic-state">All goals completed! 🐙</span></span> -- works

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-6410">example</span> <span class="unknown token" data-binding="">{</span><span class="var token" data-binding="var-_uniq.6240" data-verso-hover="27">P</span> <span class="unknown token" data-binding="">:</span> <span class="sort token" data-binding="" data-verso-hover="28">Prop</span><span class="unknown token" data-binding="">}</span> <span class="unknown token" data-binding="">:</span> <span class="var token" data-binding="var-_uniq.6240" data-verso-hover="27">P</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5622247238529123836-6436-6438"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6436" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5622247238529123836-6436-6438"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6240" data-verso-hover="27">P</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="28">Prop</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.6240" data-verso-hover="27">P</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5622247238529123836-6441-6448"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">No matching assumptions.</code></span></span><span class="keyword token" data-binding="kw-occ-tacticAssump'-6441">assump'</span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5622247238529123836-6441-6448"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.6240" data-verso-hover="27">P</span></span><span class="colon">:</span><span class="type"><span class="sort token" data-binding="" data-verso-hover="28">Prop</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="var token" data-binding="var-_uniq.6240" data-verso-hover="27">P</span></span></span></span></span></span> -- throws error "No matching assumptions."
<span class="unknown token" data-binding=""></span></code><p>
            …we get an error thrown if there are no matching assumptions.</p>
          </section>
        <section>
          <h2>
            Searching Concisely Using <code>findM?</code></h2>
          <p>
            There’s already a function called <code>findM?</code> which implements the sort of thing we did — looping over a bunch of items and returning one when a property is true.</p>
          <code class="hl lean block" data-lean-context="comparingGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-6786">elab</span> <span class="literal string token" data-binding="" data-verso-hover="137">"assump''"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6814">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-6819">let</span> <span class="var token" data-binding="var-_uniq.6324" data-verso-hover="129">goal_decl</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getGoalDecl" data-verso-hover="123">getGoalDecl</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-6851">let</span> <span class="var token" data-binding="var-_uniq.6352" data-verso-hover="114">hyp_decls</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getHypotheses" data-verso-hover="112">getHypotheses</span>

  -- check if any of the hypotheses matches the goal.
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-6940">let</span> <span class="var token" data-binding="var-_uniq.6722" data-verso-hover="138">matching_hyp_decl</span> <span class="unknown token" data-binding="">←</span> <span class="var token" data-binding="var-_uniq.6352" data-verso-hover="114">hyp_decls</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.findM?" data-verso-hover="139">findM?</span> <span class="unknown token" data-binding="">(</span>
    -- when isDefEq returns true, return the successful hyp_decl
    -- if it never does, we return none
    <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.fun-7094">fun</span> <span class="var token" data-binding="var-_uniq.6416" data-verso-hover="61">hyp_decl</span> <span class="unknown token" data-binding="">=&gt;</span>
      <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.termReturn-7116" data-verso-hover="140">return</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="var token" data-binding="var-_uniq.6416" data-verso-hover="61">hyp_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span> <span class="var token" data-binding="var-_uniq.6324" data-verso-hover="129">goal_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.MetavarDecl.type" data-verso-hover="131">type</span>
  <span class="unknown token" data-binding="">)</span>

   -- close the goal, or fail if no hypothesis matched
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doMatch-7226">match</span> <span class="var token" data-binding="var-_uniq.6722" data-verso-hover="138">matching_hyp_decl</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doMatch-7226">with</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Option.some" data-verso-hover="141">some</span> <span class="var token" data-binding="var-_uniq.6737" data-verso-hover="61">hyp_decl</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.closeMainGoal" data-verso-hover="132">closeMainGoal</span> <span class="unknown token" data-binding="">`assump''</span> <span class="var token" data-binding="var-_uniq.6737" data-verso-hover="61">hyp_decl</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.toExpr" data-verso-hover="133">toExpr</span>
  <span class="unknown token" data-binding="">|</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="142">none</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.termThrowError__-7328" data-verso-hover="88">throwError</span> <span class="unknown token" data-binding="">"No matching assumptions."</span>
<span class="unknown token" data-binding=""></span></code><p>
            Note that this function requires the use of <code>(Option.)some</code> and <code>(Option.)none</code>.  This is because <code>findM?</code> must always return something of a consistent type. So it will sometimes return a hypothesis (wrapped in <code>Option.some</code>, if the hypothesis is found), and sometimes nothing (an an <code>Option.none</code>, if the hypothesis is not found).
</p>
          </section>
        </div>
      </div>
    </body>
  </html>

