<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Adding Goals and Hypotheses — Hands-on Lean 4 Tactic Writing</title><style>


.hl.lean {
  white-space: pre;
  font-weight: normal;
  font-style: normal;
}

.hl.lean .keyword {
  font-weight : bold;
}

.hl.lean .var {
  font-style: italic;
  position: relative;
}

.hover-container {
  width: 0;
  height: 0;
  position: relative;
  display: inline;
}

.hl.lean a {
  color: inherit;
  text-decoration: currentcolor underline dotted;
}

.hl.lean a:hover {
  text-decoration: currentcolor underline solid;
}

.hl.lean .hover-info {
  white-space: normal;
}

.hl.lean .token .hover-info {
  display: none;
  position: absolute;
  background-color: #e5e5e5;
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 300;
  font-size: inherit;
}

.hl.lean .hover-info.messages {
  max-height: 10rem;
  overflow-y: auto;
  overflow-x: hidden;
  scrollbar-gutter: stable;
  padding: 0 0.5rem 0 0;
  display: block;
}

.hl.lean .hover-info code {
  white-space: pre-wrap;
}

.hl.lean .hover-info.messages > code {
  padding: 0.5rem;
  display: block;
  width: fit-content;
}

.hl.lean .hover-info.messages > code:only-child {
  margin: 0;
}

.hl.lean .hover-info.messages > code {
  margin: 0.1rem;
}

.hl.lean .hover-info.messages > code:not(:first-child) {
  margin-top: 0rem;
}

/*
@media (hover: hover) {
  .hl.lean .has-info:hover > .hover-container > .hover-info:not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .has-info:hover > .hover-container > .hover-info,
  .hl.lean .token:hover > .hover-container > .hover-info:not(.has-info *):not(.tactic *),
  .hl.lean .tactic:has(> .tactic-toggle:checked) .token:hover > .hover-container > .hover-info:not(.has-info *) {
    display: inline-block;
    position: absolute;
    top: 1rem;
    font-weight: normal;
    font-style: normal;
    width: min-content;
  }
}
*/

.hl.lean.block {
  display: block;
}

.hl.lean.inline {
  display: inline;
  white-space: pre-wrap;
}

.hl.lean .token {
  transition: all 0.25s; /* Slight fade for highlights */
}

@media (hover: hover) {
  .hl.lean .token.binding-hl, .hl.lean .literal.string:hover, .hl.lean .token.typed:hover {
    background-color: #eee;
    border-radius: 2px;
    transition: none;
  }
}


.hl.lean .has-info {
  text-decoration-style: wavy;
  text-decoration-line: underline;
  text-decoration-thickness: from-font;
}

.hl.lean .has-info .hover-info {
  display: none;
  position: absolute;
  transform: translate(0.25rem, 0.3rem);
  border: 1px solid black;
  padding: 0.5rem;
  z-index: 400;
  text-align: left;
}

.hl.lean .has-info.error {
  text-decoration-color: red;
}

@media (hover: hover) {
  .hl.lean .has-info.error:hover {
    background-color: #ffb3b3;
  }
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #ffb3b3;
}

.tippy-box[data-theme~='error'] .hl.lean .hover-info.messages > code.error {
  background: none;
  border: none;
}

.error pre {
    color: red;
}

.hl.lean .has-info.warning {
  text-decoration-color: var(--verso-warning-color);
}

@media (hover: hover) {
  .hl.lean .has-info.warning:hover {
    background-color:var(--verso-warning-color);
  }
}

.hl.lean .hover-info.messages > code.warning {
  background-color: var(--verso-warning-color);
}

.hl.lean .hover-info.messages > code.error {
  background-color: #e5e5e5;
  border-left: 0.2rem solid var(--verso-warning-color);
}

.tippy-box[data-theme~='warning'] .hl.lean .hover-info.messages > code.warning {
  background: none;
  border: none;
}


.hl.lean .has-info.info {
  text-decoration-color: blue;
}

@media (hover: hover) {
  .hl.lean .has-info.info:hover {
    background-color: #4777ff;
  }
}


.hl.lean .hover-info.messages > code.info {
  background-color: #e5e5e5;
  border-left: 0.2rem solid #4777ff;
}

.tippy-box[data-theme~='info'] .hl.lean .hover-info.messages > code.info {
  background: none;
  border: none;
}

.hl.lean div.docstring {
  font-family: sans-serif;
  white-space: normal;
  max-width: 40rem;
  width: max-content;
}

.hl.lean div.docstring > :last-child {
  margin-bottom: 0;
}

.hl.lean div.docstring > :first-child {
  margin-top: 0;
}

.hl.lean .hover-info .sep {
  display: block;
  width: auto;
  margin-left: 1rem;
  margin-right: 1rem;
  margin-top: 0.5rem;
  margin-bottom: 0.5rem;
  padding: 0;
  height: 1px;
  border-top: 1px solid #ccc;
}

.hl.lean code {
  font-family: monospace;
}

.hl.lean .tactic-state {
  display: none;
  position: relative;
  left: 2rem;
  width: fit-content;
  border: 1px solid #888888;
  border-radius: 0.1rem;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
  z-index: 200;
}

.hl.lean.popup .tactic-state {
  position: static;
  display: block;
  width: auto;
  border: none;
  padding: 0.5rem;
  font-family: sans-serif;
  background-color: #ffffff;
}


.hl.lean .tactic {
  position: relative;
}

.hl.lean .tactic-toggle:checked ~ .tactic-state {
  display: block;
}

/*
@media (hover: hover) {
  .hl.lean .tactic:hover > .tactic-toggle:not(:checked) ~ .tactic-state {
    display: block;
    position: absolute;
    left: 0;
    transform: translate(0.25rem, 0);
    z-index: 250;
  }
}
*/

.hl.lean .tactic > label {
  position: relative;
  transition: all 0.5s;
}

@media (hover: hover) {
  .hl.lean .tactic > label:hover {
    border-bottom: 1px dotted #bbbbbb;
  }
}

.hl.lean .tactic-toggle {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .tactic > label::after {
  content: "";
  border: 1px solid #bbbbbb;
  border-radius: 1rem;
  height: 0.25rem;
  vertical-align: middle;
  width: 0.6rem;
  margin-left: 0.1rem;
  margin-right: 0.1rem;
  display: inline-block;
  transition: all 0.5s;
}

/*
@media (hover: hover) {
  .hl.lean .tactic > label:hover::after {
    border: 1px solid #aaaaaa;
    background-color: #aaaaaa;
    transition: all 0.5s;
  }
}
*/

.hl.lean .tactic > label:has(+ .tactic-toggle:checked)::after {
  border: 1px solid #999999;
  background-color: #999999;
  transition: all 0.5s;
}

.hl.lean .tactic-state .goal + .goal {
  margin-top: 1.5rem;
}

.hl.lean .tactic-state summary {
  margin-left: -0.5rem;
}

.hl.lean .tactic-state details {
  padding-left: 0.5rem;
}

.hl.lean .case-label {
  display: block;
  position: relative;
}

.hl.lean .case-label input[type="checkbox"] {
  position: absolute;
  top: 0;
  left: 0;
  opacity: 0;
  height: 0;
  width: 0;
  z-index: -10;
}

.hl.lean .case-label:has(input[type="checkbox"])::before {
  width: 1rem;
  height: 1rem;
  display: inline-block;
  background-color: black;
  content: ' ';
  transition: ease 0.2s;
  margin-right: 0.7rem;
  clip-path: polygon(100% 0, 0 0, 50% 100%);
  width: 0.6rem;
  height: 0.6rem;
}

.hl.lean .case-label:has(input[type="checkbox"]:not(:checked))::before {
  transform: rotate(-90deg);
}

.hl.lean .case-label:has(input[type="checkbox"]) {

}

.hl.lean .case-label:has(input[type="checkbox"]:checked) {

}


.hl.lean .tactic-state .labeled-case > :not(:first-child) {
  max-height: 0px;
  display: block;
  overflow: hidden;
  transition: max-height 0.1s ease-in;
  margin-left: 0.5rem;
  margin-top: 0.1rem;
}

.hl.lean .labeled-case:has(.case-label input[type="checkbox"]:checked) > :not(:first-child) {
  max-height: 100%;
}


.hl.lean .tactic-state .goal-name::before {
  font-style: normal;
  content: "case ";
}

.hl.lean .tactic-state .goal-name {
  font-style: italic;
  font-family: monospace;
}

.hl.lean .tactic-state .hypotheses {
  display: table;
}

.hl.lean .tactic-state .hypothesis {
  display: table-row;
}

.hl.lean .tactic-state .hypothesis > * {
  display: table-cell;
}


.hl.lean .tactic-state .hypotheses .colon {
  text-align: center;
  min-width: 1rem;
}

.hl.lean .tactic-state .hypotheses .name {
  text-align: right;
}

.hl.lean .tactic-state .hypotheses .name,
.hl.lean .tactic-state .hypotheses .type,
.hl.lean .tactic-state .conclusion .type {
  font-family: monospace;
}

.tippy-box[data-theme~='lean'] {
  background-color: #e5e5e5;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='lean'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
}
.tippy-box[data-theme~='lean'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
}

.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: #e5e5e5;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='top'] > .tippy-arrow::after {
  bottom: -11px;
  border-width: 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::before {
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='bottom'] > .tippy-arrow::after {
  top: -11px;
  border-width: 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: #e5e5e5;
  border-width: 11px 0 11px 11px;
}
.tippy-box[data-theme~='message'][data-placement^='left'] > .tippy-arrow::after {
  right: -11px;
  border-width: 11px 0 11px 11px;
}

.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: #e5e5e5;
  border-width: 11px 11px 11px 0;
}
.tippy-box[data-theme~='message'][data-placement^='right'] > .tippy-arrow::after {
  left: -11px;
  border-width: 11px 11px 11px 0;
}



.tippy-box[data-theme~='warning'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid var(--verso-warning-color);
}

.tippy-box[data-theme~='error'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #f7a7af;
}

.tippy-box[data-theme~='info'] {
  background-color: #e5e5e5;
  color: black;
  border: 3px solid #99b3c2;
}



.tippy-box[data-theme~='tactic'] {
  background-color: white;
  color: black;
  border: 1px solid black;
}
.tippy-box[data-theme~='tactic'][data-placement^='top'] > .tippy-arrow::before {
  border-top-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='bottom'] > .tippy-arrow::before {
  border-bottom-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='left'] > .tippy-arrow::before {
  border-left-color: white;
}
.tippy-box[data-theme~='tactic'][data-placement^='right'] > .tippy-arrow::before {
  border-right-color: white;
}


</style>
<script>
      

window.onload = () => {

    // Don't show hovers inside of closed tactic states
    function blockedByTactic(elem) {
      let parent = elem.parentNode;
      while (parent && "classList" in parent) {
        if (parent.classList.contains("tactic")) {
          const toggle = parent.querySelector("input.tactic-toggle");
          if (toggle) {
            return !toggle.checked;
          }
        }
        parent = parent.parentNode;
      }
      return false;
    }

    function blockedByTippy(elem) {
      // Don't show a new hover until the old ones are all closed.
      // Scoped to the nearest "top-level block" to avoid being O(n) in the size of the document.
      var block = elem;
      const topLevel = new Set(["section", "body", "html", "nav", "header"]);
      while (block.parentNode && !topLevel.has(block.parentNode.nodeName.toLowerCase())) {
        block = block.parentNode;
      }
      for (const child of block.querySelectorAll(".token, .has-info")) {
        if (child._tippy && child._tippy.state.isVisible) { return true };
      }
      return false;
    }

    for (const c of document.querySelectorAll(".hl.lean .token")) {
        if (c.dataset.binding != "") {
            c.addEventListener("mouseover", (event) => {
                if (blockedByTactic(c)) {return;}
                const context = c.closest(".hl.lean").dataset.leanContext;
                for (const example of document.querySelectorAll(".hl.lean")) {
                    if (example.dataset.leanContext == context) {
                        for (const tok of example.querySelectorAll(".token")) {
                            if (c.dataset.binding == tok.dataset.binding) {
                                tok.classList.add("binding-hl");
                            }
                        }
                    }
                }
            });
        }
        c.addEventListener("mouseout", (event) => {
            for (const tok of document.querySelectorAll(".hl.lean .token")) {
                tok.classList.remove("binding-hl");
            }
        });
    }
    /* Render docstrings */
    if ('undefined' !== typeof marked) {
        for (const d of document.querySelectorAll("code.docstring, pre.docstring")) {
            const str = d.innerText;
            const html = marked.parse(str);
            const rendered = document.createElement("div");
            rendered.classList.add("docstring");
            rendered.innerHTML = html;
            d.parentNode.replaceChild(rendered, d);
        }
    }
    // Add hovers
    let siteRoot = typeof __versoSiteRoot !== 'undefined' ? __versoSiteRoot : "/";
    let docsJson = siteRoot + "-verso-docs.json";
    fetch(docsJson).then((resp) => resp.json()).then((versoDocData) => {

      const defaultTippyProps = {
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        theme: "lean",
        maxWidth: "none",
        appendTo: () => document.body,
        interactive: true,
        delay: [100, null],
        ignoreAttributes: true,
        onShow(inst) {
          if (inst.reference.querySelector(".hover-info") || "versoHover" in inst.reference.dataset) {
            if (blockedByTactic(inst.reference)) { return false };
            if (blockedByTippy(inst.reference)) { return false; }
          } else { // Nothing to show here!
            return false;
          }
        },
        content (tgt) {
          const content = document.createElement("span");
          content.className = "hl lean";
          content.style.display = "block";
          content.style.maxHeight = "300px";
          content.style.overflowY = "auto";
          content.style.overflowX = "hidden";
          const hoverId = tgt.dataset.versoHover;
          const hoverInfo = tgt.querySelector(".hover-info");
          if (hoverId) { // Docstrings from the table
            // TODO stop doing an implicit conversion from string to number here
            let data = versoDocData[hoverId];
            if (data) {
              const info = document.createElement("span");
              info.className = "hover-info";
              info.style.display = "block";
              info.innerHTML = data;
              content.appendChild(info);
              /* Render docstrings - TODO server-side */
              if ('undefined' !== typeof marked) {
                  for (const d of content.querySelectorAll("code.docstring, pre.docstring")) {
                      const str = d.innerText;
                      const html = marked.parse(str);
                      const rendered = document.createElement("div");
                      rendered.classList.add("docstring");
                      rendered.innerHTML = html;
                      d.parentNode.replaceChild(rendered, d);
                  }
              }
            } else {
              content.innerHTML = "Failed to load doc ID: " + hoverId;
            }
          } else if (hoverInfo) { // The inline info, still used for compiler messages
            content.appendChild(hoverInfo.cloneNode(true));
          }
          return content;
        }
      };

      const addTippy = (selector, props) => {
        tippy(selector, Object.assign({}, defaultTippyProps, props));
      };
      addTippy('.hl.lean .const.token, .hl.lean .keyword.token, .hl.lean .literal.token, .hl.lean .option.token, .hl.lean .var.token, .hl.lean .typed.token', {theme: 'lean'});
      addTippy('.hl.lean .has-info.warning', {theme: 'warning message'});
      addTippy('.hl.lean .has-info.info', {theme: 'info message'});
      addTippy('.hl.lean .has-info.error', {theme: 'error message'});

      tippy('.hl.lean .tactic', {
        allowHtml: true,
        /* DEBUG -- remove the space: * /
        onHide(any) { return false; },
        trigger: "click",
        // */
        maxWidth: "none",
        onShow(inst) {
          const toggle = inst.reference.querySelector("input.tactic-toggle");
          if (toggle && toggle.checked) {
            return false;
          }
          if (blockedByTippy(inst.reference)) { return false; }
        },
        theme: "tactic",
        placement: 'bottom-start',
        content (tgt) {
          const content = document.createElement("span");
          const state = tgt.querySelector(".tactic-state").cloneNode(true);
          state.style.display = "block";
          content.appendChild(state);
          content.style.display = "block";
          content.className = "hl lean popup";
          return content;
        }
      });
  });
}

</script>
    
<script>
      
document.addEventListener("DOMContentLoaded", () => {
    for (const m of document.querySelectorAll(".math.inline")) {
        katex.render(m.textContent, m, {throwOnError: false, displayMode: false});
    }
    for (const m of document.querySelectorAll(".math.display")) {
        katex.render(m.textContent, m, {throwOnError: false, displayMode: true});
    }
});
</script>
    
<script src="../-verso-js/popper.js"></script>
    <script src="../-verso-js/tippy.js"></script>
    <link rel="stylesheet" href="../-verso-css/tippy-border.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked@11.1.1/marked.min.js" integrity="sha384-zbcZAIxlvJtNE3Dp5nxLXdXtXyxwOdnILY1TDPVmKFhl4r4nSUG1r8bcFXGVa4Te" crossorigin="anonymous"></script>
    <link rel="icon" type="image/x-icon" href="../static/img/favicon.ico">
    <link rel="stylesheet" href="../static/style.css">
    <link rel="stylesheet" href="../static/navbar.css">
    <link rel="stylesheet" href="../static/navbar-colors.css">
    <script crossorigin="anonymous" src="https://code.jquery.com/jquery-2.2.4.js"></script>
    <script src="../static/build-nav.js"></script>
    <script>
      window.onload=function(){buildNav();}</script>
    </head>
  <body>
    <header>
      <div class="inner-wrap">
        <a class="logo" href="../">Hands-on Lean 4 Tactic Writing</a><nav class="top" role="navigation">
          <ol>
            <li>
              <a href="../Introduction">Introduction</a></li>
            <li>
              <a href="../Reading-and-Changing-the-Goal">Reading and Changing the Goal</a></li>
            <li>
              <a href="../Reading-and-Changing-the-Hypotheses">Reading and Changing the Hypotheses</a></li>
            <li>
              <a href="../Comparing-Goals-and-Hypotheses">Comparing Goals and Hypotheses</a></li>
            <li>
              <a href="../Adding-Goals-and-Hypotheses">Adding Goals and Hypotheses</a></li>
            <li>
              <a href="../Manipulating-Expressions">Manipulating Expressions</a></li>
            <li>
              <a href="../Manipulating-Subexpressions">Manipulating Subexpressions</a></li>
            <li>
              <a href="../Final-Project-Autogeneralize">Final Project: The Autogeneralize Tactic</a></li>
            </ol>
          </nav>
        </div>
      </header>
    <div class="main" role="main">
      <div class="wrap">
        <h1>
          Adding Goals and Hypotheses</h1>
        <p>
          By the end of this section, you'll create a version of the <code>apply</code> tactic.  This tactic "applies" a lemma which has a conclusion that matches the current goal, and updates the current goal accordingly.</p>
        <section>
          <h2>
            Adding a Goal</h2>
          <p>
            We know how to manipulate a list of goals in Lean (for example, rotating the order of them).
We will now look at modifying the tactic state beyond just manipulating the list of goals.</p>
          <p>
            <strong>Creating a goal</strong> in Lean is really <strong>creating a metavariable</strong> (a variable whose value a.k.a proof isn’t known yet).
<strong>Proving a goal</strong> in Lean is <strong>assigning a value a.k.a proof to that metavariable</strong>.</p>
          <p>
            We can extract out the basics of goal creation into a helper tactic: <code>createGoal</code>.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.open-832" data-verso-hover="0">open</span> <span class="unknown token" data-binding="">Lean</span> <span class="unknown token" data-binding="">Meta</span> <span class="unknown token" data-binding="">Elab</span> <span class="unknown token" data-binding="">Tactic</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-860">def</span> <span class="const token" data-binding="const-createGoal" data-verso-hover="143">createGoal</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.2" data-verso-hover="67">goalType</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="const token" data-binding="const-Unit" data-verso-hover="84">Unit</span> <span class="unknown token" data-binding="">:=</span>
<span class="const token" data-binding="const-Lean.Elab.Tactic.withMainContext" data-verso-hover="81">withMainContext</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-927">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-932">let</span> <span class="var token" data-binding="var-_uniq.321" data-verso-hover="67">goal</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.mkFreshExprMVar" data-verso-hover="144">mkFreshExprMVar</span> <span class="var token" data-binding="var-_uniq.2" data-verso-hover="67">goalType</span>
  <span class="const token" data-binding="const-Lean.Elab.Tactic.appendGoals" data-verso-hover="145">appendGoals</span> <span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.321" data-verso-hover="67">goal</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.Expr.mvarId!" data-verso-hover="146">mvarId!</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
            We can see this in action here. If we want our goal to be “find an instance of type <code>Nat</code>”, we create a metavariable with type <code>Nat</code>, like so:</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-1165">elab</span> <span class="literal string token" data-binding="" data-verso-hover="147">"create_nat_goal"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-1200">do</span>
  -- make the goal to find an instance of type "Nat"
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-1258">let</span> <span class="var token" data-binding="var-_uniq.437" data-verso-hover="67">goalType</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Expr.const" data-verso-hover="134">Expr.const</span> <span class="unknown token" data-binding="">`</span><span class="unknown token" data-binding="">`</span><span class="const token" data-binding="const-Nat" data-verso-hover="72">Nat</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span><span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-createGoal" data-verso-hover="143">createGoal</span> <span class="var token" data-binding="var-_uniq.437" data-verso-hover="67">goalType</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-1319">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="11">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12830290973630335142-1342-1344"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1342" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12830290973630335142-1342-1344"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-8448377505037012659-1347-1362"><span class="keyword token" data-binding="kw-occ-tacticCreate_nat_goal-1347">create_nat_goal</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8448377505037012659-1347-1362"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="72">ℕ</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-12558767293592446206-1365-1369"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-1365" data-verso-hover="37">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12558767293592446206-1365-1369"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="72">ℕ</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-1372-1377"><span class="keyword token" data-binding="kw-occ-Mathlib.Tactic.useSyntax-1372" data-verso-hover="148">use</span> <span class="typed token" data-binding="" data-verso-hover="11">5</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-1372-1377"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
            If instead, we want to create a goal to be “prove 0 = 0”, then we create a metavariable with type <code>0 = 0</code>.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-1507">elab</span> <span class="literal string token" data-binding="" data-verso-hover="149">"create_reflexivity_goal"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-1550">do</span>
  -- make the metavariable goal to prove that "0 = 0"
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-1609">let</span> <span class="var token" data-binding="var-_uniq.1491" data-verso-hover="67">goalType</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.mkEq" data-verso-hover="150">mkEq</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-createGoal" data-verso-hover="143">createGoal</span> <span class="var token" data-binding="var-_uniq.1491" data-verso-hover="67">goalType</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-1676">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="11">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12830290973630335142-1699-1701"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-1699" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12830290973630335142-1699-1701"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-13699332293287746700-1704-1727"><span class="keyword token" data-binding="kw-occ-tacticCreate_reflexivity_goal-1704">create_reflexivity_goal</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13699332293287746700-1704-1727"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>0</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-15160817310521252673-1730-1734"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-1730" data-verso-hover="37">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15160817310521252673-1730-1734"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>0</span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-1736-1740"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-1736" data-verso-hover="37">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-1736-1740"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
            Until now, we had to be in an <code>elab</code> to decide what goal would be created.</p>
          <p>
            But now, we can create a tactic that allows us to decide what the new goal is from within the proof itself.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-1943">elab</span> <span class="literal string token" data-binding="" data-verso-hover="151">"create_goal"</span> <span class="var token" data-binding="var-_uniq.2444" data-verso-hover="95">t</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="99">term</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-1981">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-1986">let</span> <span class="var token" data-binding="var-_uniq.2730" data-verso-hover="67">e</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Term.elabTerm" data-verso-hover="152">Term.elabTerm</span> <span class="var token" data-binding="var-_uniq.2444" data-verso-hover="95">t</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="142">none</span>
  <span class="const token" data-binding="const-createGoal" data-verso-hover="143">createGoal</span> <span class="var token" data-binding="var-_uniq.2730" data-verso-hover="67">e</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-2033">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="11">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12830290973630335142-2056-2058"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-2056" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12830290973630335142-2056-2058"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-1437971839397580557-2061-2086"><span class="keyword token" data-binding="kw-occ-tacticCreate_goal_-2061">create_goal</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1437971839397580557-2061-2086"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> 2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-8983056180601222552-2089-2093"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-2089" data-verso-hover="37">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8983056180601222552-2089-2093"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> 2</span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-2095-2114"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-2095" data-verso-hover="154">exact</span> <span class="const token" data-binding="const-Nat.prime_two" data-verso-hover="155">Nat.prime_two</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-2095-2114"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></section>
        <section>
          <h2>
            Proving a Goal</h2>
          <p>
            Remember:</p>
          <ul>
            <li>
              <p>
                <strong>Creating a goal</strong> in Lean is really <strong>creating a metavariable</strong> (a variable whose value a.k.a proof isn’t known yet).</p>
              </li>
            <li>
              <p>
                <strong>Proving a goal</strong> in Lean is <strong>assigning a value a.k.a proof to that metavariable</strong>.</p>
              </li>
            </ul>
          <p>
            So, we can prove a goal by passing in an expression for the term that matches the goal's type.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2461">def</span> <span class="const token" data-binding="const-proveGoal" data-verso-hover="156">proveGoal</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.3380" data-verso-hover="67">proof</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="const token" data-binding="const-Unit" data-verso-hover="84">Unit</span> <span class="unknown token" data-binding="">:=</span>
<span class="const token" data-binding="const-Lean.Elab.Tactic.withMainContext" data-verso-hover="81">withMainContext</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-2524">do</span>
  <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainGoal" data-verso-hover="9">getMainGoal</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.MVarId.assign" data-verso-hover="157">assign</span> <span class="var token" data-binding="var-_uniq.3380" data-verso-hover="67">proof</span>
  <span class="const token" data-binding="const-Lean.Elab.Tactic.replaceMainGoal" data-verso-hover="158">replaceMainGoal</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
            We can see this in action here:</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-2630">elab</span> <span class="literal string token" data-binding="" data-verso-hover="159">"prove_goal"</span> <span class="var token" data-binding="var-_uniq.3668" data-verso-hover="95">t</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="99">term</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-2667">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-2672">let</span> <span class="var token" data-binding="var-_uniq.3954" data-verso-hover="67">e</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Term.elabTerm" data-verso-hover="152">Term.elabTerm</span> <span class="var token" data-binding="var-_uniq.3668" data-verso-hover="95">t</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="142">none</span>
  <span class="const token" data-binding="const-proveGoal" data-verso-hover="156">proveGoal</span> <span class="var token" data-binding="var-_uniq.3954" data-verso-hover="67">e</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-2718">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="11">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12830290973630335142-2741-2743"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-2741" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12830290973630335142-2741-2743"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-1437971839397580557-2746-2771"><span class="keyword token" data-binding="kw-occ-tacticCreate_goal_-2746">create_goal</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1437971839397580557-2746-2771"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> 2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-8983056180601222552-2774-2778"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-2774" data-verso-hover="37">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-8983056180601222552-2774-2778"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> 2</span></span></span></span></span><span class="unknown token" data-binding="">;</span> <span class="tactic"><label for="tactic-state-7-2780-2804"><span class="keyword token" data-binding="kw-occ-tacticProve_goal_-2780">prove_goal</span> <span class="const token" data-binding="const-Nat.prime_two" data-verso-hover="155">Nat.prime_two</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-2780-2804"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></section>
        <section>
          <h2>
            Adding a Hypothesis</h2>
          <p>
            Similarly, we can extract out the basics of hypothesis creation into a helper tactic: <code>createHypothesis</code>.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-2953">def</span> <span class="const token" data-binding="const-createHypothesis" data-verso-hover="160">createHypothesis</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4602" data-verso-hover="67">hypType</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4604" data-verso-hover="67">hypProof</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.4608" data-verso-hover="161">hypName</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">`h</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span>
  <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="const token" data-binding="const-Unit" data-verso-hover="84">Unit</span> <span class="unknown token" data-binding="">:=</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-3047">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-3052">let</span> <span class="var token" data-binding="var-_uniq.4645" data-verso-hover="162">hyp</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Meta.Hypothesis" data-verso-hover="163">Hypothesis</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span>
    <span class="const token" data-binding="const-Lean.Meta.Hypothesis.userName" data-verso-hover="164">userName</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.4608" data-verso-hover="161">hypName</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-Lean.Meta.Hypothesis.type" data-verso-hover="165">type</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.4602" data-verso-hover="67">hypType</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-Lean.Meta.Hypothesis.value" data-verso-hover="165">value</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.4604" data-verso-hover="67">hypProof</span>
  <span class="unknown token" data-binding="">}</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-3152">let</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.4914" data-verso-hover="8">new_goal</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainGoal" data-verso-hover="9">getMainGoal</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.MVarId.assertHypotheses" data-verso-hover="166">assertHypotheses</span> <span class="unknown token" data-binding="">(</span>
    <span class="const token" data-binding="const-List.toArray" data-verso-hover="167">List.toArray</span> <span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.4645" data-verso-hover="162">hyp</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-Lean.Elab.Tactic.setGoals" data-verso-hover="23">setGoals</span> <span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.4914" data-verso-hover="8">new_goal</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
            Here’s an example of adding a hypothesis that looks like <code>h : ℕ</code>.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-3348">elab</span> <span class="literal string token" data-binding="" data-verso-hover="168">"create_nat_hypothesis"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-3389">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-3394">let</span> <span class="var token" data-binding="var-_uniq.5107" data-verso-hover="67">hypType</span> <span class="unknown token" data-binding="">:=</span> <span class="const token" data-binding="const-Lean.Expr.const" data-verso-hover="134">Expr.const</span> <span class="unknown token" data-binding="">`</span><span class="unknown token" data-binding="">`</span><span class="const token" data-binding="const-Nat" data-verso-hover="72">Nat</span> <span class="unknown token" data-binding="">[</span><span class="unknown token" data-binding="">]</span> -- type of Nat
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-3446">let</span> <span class="var token" data-binding="var-_uniq.5181" data-verso-hover="67">hypProof</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">)</span> -- term of 0
  <span class="const token" data-binding="const-createHypothesis" data-verso-hover="160">createHypothesis</span> <span class="var token" data-binding="var-_uniq.5107" data-verso-hover="67">hypType</span> <span class="var token" data-binding="var-_uniq.5181" data-verso-hover="67">hypProof</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-3523">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="11">3</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-12830290973630335142-3546-3548"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-3546" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-12830290973630335142-3546-3548"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-3786193978942641209-3551-3572"><span class="keyword token" data-binding="kw-occ-tacticCreate_nat_hypothesis-3551">create_nat_hypothesis</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3786193978942641209-3551-3572"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.5874" data-verso-hover="11">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Nat" data-verso-hover="72">ℕ</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>3</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-3575-3579"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-3575" data-verso-hover="37">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-3575-3579"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
            Here’s an example of adding a hypothesis that is a proposition <code>0 = 0</code>.</p>
          <pre>elab "create_reflexivity_hypothesis" : tactic =&gt; do
  let hypType ← mkEq (toExpr 0) (toExpr 0) -- statement that "0 = 0"
  let hypProof ← mkAppM ``Eq.refl #[toExpr 0] -- proof that "0 = 0"
  createHypothesis hypType hypProof

example : 1 + 2 = 3 := by
  create_reflexivity_hypothesis
  simp
</pre></section>
        <section>
          <h2>
            Did We Prove the Hypothesis?</h2>
          <p>
            Lean will technically let us create bogus hypotheses.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-4063">elab</span> <span class="literal string token" data-binding="" data-verso-hover="169">"create_bogus_hypothesis"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-4106">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-4111">let</span> <span class="var token" data-binding="var-_uniq.6327" data-verso-hover="67">hypType</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.mkEq" data-verso-hover="150">mkEq</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span><span class="unknown token" data-binding="">)</span>  -- statement that "0 = 1"
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-4183">let</span> <span class="var token" data-binding="var-_uniq.6446" data-verso-hover="67">hypProof</span>  <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.mkAppM" data-verso-hover="170">mkAppM</span> <span class="unknown token" data-binding="">`</span><span class="unknown token" data-binding="">`</span><span class="const token" data-binding="const-Eq.refl" data-verso-hover="171">Eq.refl</span> <span class="unknown token" data-binding="">#[</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">]</span> -- proof that "0 = 0"
  <span class="const token" data-binding="const-createHypothesis" data-verso-hover="160">createHypothesis</span> <span class="var token" data-binding="var-_uniq.6327" data-verso-hover="67">hypType</span> <span class="var token" data-binding="var-_uniq.6446" data-verso-hover="67">hypProof</span>
<span class="unknown token" data-binding=""></span></code><code class="hl lean block" data-lean-context="AGH"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">declaration uses 'sorry'</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-4305">example</span></span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">=</span><span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-13324721092479414549-4322-4324"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-4322" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13324721092479414549-4322-4324"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>1</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-3315692223222433435-4327-4350"><span class="keyword token" data-binding="kw-occ-tacticCreate_bogus_hypothesis-4327">create_bogus_hypothesis</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3315692223222433435-4327-4350"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7281" data-verso-hover="172">h</span></span><span class="colon">:</span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>1</span></span></span></span></span> -- "0=1" is now a hypothesis
  <span class="tactic"><label for="tactic-state-7-4382-4387"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.tacticSorry-4382" data-verso-hover="42">sorry</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-4382-4387"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
            But, if we actually try to use that hypothesis to prove a theorem, it will throw a low-level error in the kernel.  A similar thing occurred previously with <code>setGoals</code>, where we could drop all active goals from the tactic state, but we got a kernel error if we tried to then finish the proof.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">(kernel) declaration type mismatch, '_example' has type
  0 = 0
but it is expected to have type
  0 = 1</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-4709">example</span></span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">=</span><span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-13324721092479414549-4726-4728"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-4726" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13324721092479414549-4726-4728"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>1</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5055901371270601563-4731-4754"><span class="keyword token" data-binding="kw-occ-tacticCreate_bogus_hypothesis-4731">create_bogus_hypothesis</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5055901371270601563-4731-4754"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.7404" data-verso-hover="172">h</span></span><span class="colon">:</span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>1</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>1</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-4757-4767"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-4757" data-verso-hover="173">assumption</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-4757-4767"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
            Ideally, we want to catch this error earlier.</p>
          <p>
            To do that, we want our tactic to check that the hypothesis statement matches the proof. That is, by propositions-as-types and proofs-as-terms, the inferred type of the <code>hypProof</code> should be <code>hypType</code>.</p>
          <p>
            So let's modify our <code>createHypothesis</code> function to perform this check.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-5106">def</span> <span class="const token" data-binding="const-createHypothesisGuarded" data-verso-hover="174">createHypothesisGuarded</span>
  <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7286" data-verso-hover="67">hypType</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7288" data-verso-hover="67">hypProof</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.7292" data-verso-hover="161">hypName</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">`h</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">:</span>
  <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="const token" data-binding="const-Unit" data-verso-hover="84">Unit</span> <span class="unknown token" data-binding="">:=</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-5206">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-5211">unless</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="var token" data-binding="var-_uniq.7286" data-verso-hover="67">hypType</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.inferType" data-verso-hover="175">inferType</span> <span class="var token" data-binding="var-_uniq.7288" data-verso-hover="67">hypProof</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-5211">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.termThrowError__-5270" data-verso-hover="88">throwError</span>
      <span class="unknown token" data-binding="">"The proof used for creating the hypothesis
      does not match the expected type."</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-5374">let</span> <span class="var token" data-binding="var-_uniq.8179" data-verso-hover="162">hyp</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Meta.Hypothesis" data-verso-hover="163">Hypothesis</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">{</span>
    <span class="const token" data-binding="const-Lean.Meta.Hypothesis.userName" data-verso-hover="164">userName</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7292" data-verso-hover="161">hypName</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-Lean.Meta.Hypothesis.type" data-verso-hover="165">type</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7286" data-verso-hover="67">hypType</span><span class="unknown token" data-binding="">,</span>
    <span class="const token" data-binding="const-Lean.Meta.Hypothesis.value" data-verso-hover="165">value</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.7288" data-verso-hover="67">hypProof</span>
  <span class="unknown token" data-binding="">}</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-5474">let</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.8278" data-verso-hover="8">new_goal</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">←</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainGoal" data-verso-hover="9">getMainGoal</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.MVarId.assertHypotheses" data-verso-hover="166">assertHypotheses</span> <span class="unknown token" data-binding="">(</span>
    <span class="const token" data-binding="const-List.toArray" data-verso-hover="167">List.toArray</span> <span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.8179" data-verso-hover="162">hyp</span><span class="unknown token" data-binding="">]</span>
  <span class="unknown token" data-binding="">)</span>
  <span class="const token" data-binding="const-Lean.Elab.Tactic.setGoals" data-verso-hover="23">setGoals</span> <span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.8278" data-verso-hover="8">new_goal</span><span class="unknown token" data-binding="">]</span>
<span class="unknown token" data-binding=""></span></code><p>
            Here, the <code>inferType</code> function is used to deduce the type of <code>hypProof</code> (or the statement of the theorem it is a proof of, in the case of propositions). The <code>isDefEq</code> function is used to compare two expressions up to definitional equality; more will be said about this function in the later sections.</p>
          <p>
            Adding the bogus hypothesis no longer works with the <code>createHypothesisGuarded</code> function.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-6005">elab</span> <span class="literal string token" data-binding="" data-verso-hover="176">"create_bogus_hypothesis'"</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6049">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-6054">let</span> <span class="var token" data-binding="var-_uniq.8842" data-verso-hover="67">hypType</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.mkEq" data-verso-hover="150">mkEq</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span><span class="unknown token" data-binding="">)</span> -- statement that "0 = 1"
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-6125">let</span> <span class="var token" data-binding="var-_uniq.8961" data-verso-hover="67">hypProof</span>  <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.mkAppM" data-verso-hover="170">mkAppM</span> <span class="unknown token" data-binding="">`</span><span class="unknown token" data-binding="">`</span><span class="const token" data-binding="const-Eq.refl" data-verso-hover="171">Eq.refl</span> <span class="unknown token" data-binding="">#[</span><span class="const token" data-binding="const-Lean.ToExpr.toExpr" data-verso-hover="135">toExpr</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">]</span> -- proof that "0 = 0"
  <span class="const token" data-binding="const-createHypothesisGuarded" data-verso-hover="174">createHypothesisGuarded</span> <span class="var token" data-binding="var-_uniq.8842" data-verso-hover="67">hypType</span> <span class="var token" data-binding="var-_uniq.8961" data-verso-hover="67">hypProof</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-6238">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">0</span><span class="unknown token" data-binding="">=</span><span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-13324721092479414549-6255-6257"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6255" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13324721092479414549-6255-6257"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>1</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-13324721092479414549-6260-6284"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">The proof used for creating the hypothesis
      does not match the expected type.</code></span></span><span class="keyword token" data-binding="kw-occ-tacticCreate_bogus_hypothesis'-6260">create_bogus_hypothesis'</span></span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-13324721092479414549-6260-6284"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">0<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>1</span></span></span></span></span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.assumption-6287" data-verso-hover="173">assumption</span>
<span class="unknown token" data-binding=""></span></code></section>
        <section>
          <h2>
            Looking Into the Environment</h2>
          <p>
            It is possible retrieve the statement and proof of a theorem from the environment given its name using <code>(← getEnv).find?</code>.</p>
          <p>
            As an easy application of the tools we've developed so far, we can write a tactic that takes the name of a theorem in the environment and adds it as a local hypothesis.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-6643">elab</span> <span class="literal string token" data-binding="" data-verso-hover="177">"add_theorem_as_hypothesis"</span> <span class="var token" data-binding="var-_uniq.8488" data-verso-hover="178">nm</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.nameLit" data-verso-hover="179">name</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-6696">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetElse-6701">let</span> <span class="const token" data-binding="const-Option.some" data-verso-hover="141">some</span> <span class="var token" data-binding="var-_uniq.8622" data-verso-hover="180">thm</span> <span class="unknown token" data-binding="">:=</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.MonadEnv.getEnv" data-verso-hover="107">getEnv</span><span class="unknown token" data-binding="">)</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.Environment.find?" data-verso-hover="181">find?</span> <span class="var token" data-binding="var-_uniq.8488" data-verso-hover="178">nm</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.TSyntax.getName" data-verso-hover="182">getName</span> <span class="unknown token" data-binding="">|</span>
    <span class="keyword token" data-binding="kw-occ-Lean.termThrowError__-6753" data-verso-hover="88">throwError</span> <span class="keyword token" data-binding="kw-occ-termS!_-6764">s!</span><span class="unknown token" data-binding="">"The result {</span><span class="var token" data-binding="var-_uniq.8488" data-verso-hover="178">nm</span><span class="unknown token" data-binding="">} is not in the environment."</span>
  <span class="const token" data-binding="const-createHypothesisGuarded" data-verso-hover="174">createHypothesisGuarded</span> <span class="var token" data-binding="var-_uniq.8622" data-verso-hover="180">thm</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.ConstantInfo.type" data-verso-hover="183">type</span> <span class="var token" data-binding="var-_uniq.8622" data-verso-hover="180">thm</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.ConstantInfo.value!" data-verso-hover="184">value!</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-6858">example</span> <span class="unknown token" data-binding="">:</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">=</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">+</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-2285796905021659853-6885-6887"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-6885" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-2285796905021659853-6885-6887"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>2<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>1</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-18281534960873625929-6890-6929"><span class="keyword token" data-binding="kw-occ-tacticAdd_theorem_as_hypothesis_-6890">add_theorem_as_hypothesis</span> <span class="unknown token" data-binding="">`Nat.add_comm</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18281534960873625929-6890-6929"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.10114" data-verso-hover="185">h</span></span><span class="colon">:</span><span class="type">∀ (<span class="var token" data-binding="var-_uniq.10127" data-verso-hover="11">n </span><span class="var token" data-binding="var-_uniq.10128" data-verso-hover="11">m</span> : <span class="const token" data-binding="const-Nat" data-verso-hover="72">ℕ</span>), <span class="var token" data-binding="var-_uniq.10127" data-verso-hover="11">n</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span><span class="var token" data-binding="var-_uniq.10128" data-verso-hover="11">m</span><span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span><span class="var token" data-binding="var-_uniq.10128" data-verso-hover="11">m</span><span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span><span class="var token" data-binding="var-_uniq.10127" data-verso-hover="11">n</span></span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type">1<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>2<span class="const token" data-binding="const-Eq" data-verso-hover="13"> = </span>2<span class="const token" data-binding="const-HAdd.hAdd" data-verso-hover="12"> + </span>1</span></span></span></span></span> -- adds "h"
  <span class="tactic"><label for="tactic-state-7-6944-6957"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.exact-6944" data-verso-hover="154">exact</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10114" data-verso-hover="185">h</span> <span class="typed token" data-binding="" data-verso-hover="11">1</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-6944-6957"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></section>
        <section>
          <h2>
            Implementing the 'apply' Tactic</h2>
          <p>
            We typically make progress on a proof in Lean through <strong>tactics</strong>. These have the effect of replacing the current proof state with another, in a way that preserves provability (i.e., if the new set of goals is solvable, then so is the old one).</p>
          <p>
            The converse is not true - it is possible to start from a solvable tactic state and go to an unsolvable one, for example by clearing an essential hypothesis or using backwards reasoning on the goal.</p>
          <p>
            So far, we have written tactics that work on the list of active goals or add hypotheses to the local context. To better understand how tactics manipulate the proof state, let's write a simplified version of the <code>apply</code> tactic - the tactic that is routinely used in Lean for backwards reasoning, i.e., reasoning backwards from the target.</p>
          <section>
            <h3>
              An Example</h3>
            <p>
              For example, suppose the goal is to prove that <code>2 ^ 3</code> is not a prime number.</p>
            <p>
              And suppose we have a theorem called <code>Nat.Prime.not_prime_pow</code>, which says that if <code>x</code> and <code>n</code> are natural numbers and <code>2 ≤ n</code>, then <code>x ^ n</code> is not a prime number.</p>
            <p>
              A mathematician would say "to show that <code>2 ^ 3</code> is not prime, it is sufficient to show that <code>2 ≤ 3</code>, by the result <code>Nat.Prime.not_prime_pow</code>." (except maybe for the last bit).</p>
            <p>
              A Lean coder would say <code>apply Nat.Prime.not_prime_pow</code>.</p>
            <code class="hl lean block" data-lean-context="AGH"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Nat.Prime.not_prime_pow {x n : ℕ} (hn : 2 ≤ n) : ¬Nat.Prime (x ^ n)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-8289">#check</span></span> <span class="const token" data-binding="const-Nat.Prime.not_prime_pow" data-verso-hover="186">Nat.Prime.not_prime_pow</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-8321">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">¬</span> <span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">^</span> <span class="typed token" data-binding="" data-verso-hover="11">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-11502113438412779441-8355-8357"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-8355" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-11502113438412779441-8355-8357"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Not" data-verso-hover="30">¬</span><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> <span class="const token" data-binding="const-HPow.hPow" data-verso-hover="187">(</span>2<span class="const token" data-binding="const-HPow.hPow" data-verso-hover="187"> ^ </span>3<span class="const token" data-binding="const-HPow.hPow" data-verso-hover="187">)</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-14973447967242336714-8360-8389"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.apply-8360" data-verso-hover="36">apply</span> <span class="const token" data-binding="const-Nat.Prime.not_prime_pow" data-verso-hover="186">Nat.Prime.not_prime_pow</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-14973447967242336714-8360-8389"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-100" checked="checked"><span for="--verso-unique-100" class="goal-name">hn</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type">2<span class="const token" data-binding="const-LE.le" data-verso-hover="188"> ≤ </span>3</span></span></span></span></span></span>
  -- the goal is now to show that `2 ≤ 3`
  <span class="tactic"><label for="tactic-state-7-8436-8442"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-8436" data-verso-hover="189">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-8436-8442"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></section>
          <section>
            <h3>
              Implementation</h3>
            <p>
              We'll start with the scenario where we have a goal <code>Q</code> and a local hypothesis of type <code>P → Q</code>.</p>
            <pre>h: P → Q
======
⊢ Q
</pre><p>
              After calling, <code>apply</code>, we want the goal to be <code>P</code>.  (Because, indeed, it is sufficient to prove <code>P</code>.)</p>
            <pre>h: P → Q
======
⊢ P
</pre><p>
              Our high-level strategy is going to be to:</p>
            <ul>
              <li>
                <p>
                  Check whether the hypothesis <code>h</code> is an implication, i.e., of the form <code>P → Q</code></p>
                </li>
              </ul>
            <pre>h: P → Q -- this is an implication
======
⊢ Q
</pre><ul>
              <li>
                <p>
                  Check whether the conclusion of the hypothesis <code>h</code> matches the type of the current goal</p>
                </li>
              </ul>
            <pre>h: P → Q -- the conclusion of the hypothesis is Q
======
⊢ Q -- the type of the current goal is Q
</pre><ul>
              <li>
                <p>
                  Create a new goal <code>p</code> of type <code>P</code></p>
                </li>
              </ul>
            <pre>h: P → Q
======
⊢ P -- we create a new goal
⊢ Q
</pre><ul>
              <li>
                <p>
                  We can prove the goal "Q" assuming the hypothesis "P→ Q" (called <code>h</code>) and assuming we've already proved the first goal "P" (called <code>p</code>).  So, we can prove the goal "Q" by assigning it the value <code>h p</code>.</p>
                </li>
              </ul>
            <pre>h: P → Q
======
⊢ P
-- ⊢ Q -- we can prove this goal
</pre><ul>
              <li>
                <p>
                  We're done.</p>
                </li>
              </ul>
            <pre>h: P → Q
======
⊢ P
</pre><p>
              To do this, we'll use a helper function <code>createGoal'</code> which unlike our previous <code>createGoal</code>, actually returns the new goal.</p>
            <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.definition-9673">def</span> <span class="const token" data-binding="const-createGoal'" data-verso-hover="190">createGoal'</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.10382" data-verso-hover="67">goalType</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.TacticM" data-verso-hover="83">TacticM</span> <span class="const token" data-binding="const-Lean.Expr" data-verso-hover="116">Expr</span> <span class="unknown token" data-binding="">:=</span>
<span class="const token" data-binding="const-Lean.Elab.Tactic.withMainContext" data-verso-hover="81">withMainContext</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-9741">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-9746">let</span> <span class="var token" data-binding="var-_uniq.10701" data-verso-hover="67">goal</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.mkFreshExprMVar" data-verso-hover="144">mkFreshExprMVar</span> <span class="var token" data-binding="var-_uniq.10382" data-verso-hover="67">goalType</span>
  <span class="const token" data-binding="const-Lean.Elab.Tactic.appendGoals" data-verso-hover="145">appendGoals</span> <span class="unknown token" data-binding="">[</span><span class="var token" data-binding="var-_uniq.10701" data-verso-hover="67">goal</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.Expr.mvarId!" data-verso-hover="146">mvarId!</span><span class="unknown token" data-binding="">]</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doReturn-9815" data-verso-hover="3">return</span> <span class="var token" data-binding="var-_uniq.10701" data-verso-hover="67">goal</span>
<span class="unknown token" data-binding=""></span></code><p>
              Here is what this full strategy looks like translated into code.  Parts of this code are deliberately sub-optimal; we'll see ways of improving it shortly.</p>
            <p>
              And here is the tactic:</p>
            <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-10655">elab</span> <span class="literal string token" data-binding="" data-verso-hover="191">"apply_hypothesis"</span> <span class="var token" data-binding="var-_uniq.12928" data-verso-hover="95">h</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="99">term</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span>
<span class="const token" data-binding="const-Lean.Elab.Tactic.withMainContext" data-verso-hover="81">withMainContext</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-10714">do</span>

  -- ensure that the hypothesis is an implication
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-10770">let</span> <span class="var token" data-binding="var-_uniq.12998" data-verso-hover="61">hyp</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getHypothesisByTerm" data-verso-hover="94">getHypothesisByTerm</span> <span class="var token" data-binding="var-_uniq.12928" data-verso-hover="95">h</span>
  <span class="const token" data-binding="const-guard" data-verso-hover="192">guard</span> <span class="var token" data-binding="var-_uniq.12998" data-verso-hover="61">hyp</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.Expr.isArrow" data-verso-hover="193">isArrow</span>

  -- extract implication's antecedent & consequent
  -- or throw error if the hypothesis type is not a .forall
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetElse-10943">let</span> <span class="const token" data-binding="const-Lean.Expr.forallE" data-verso-hover="194">.forallE</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.13171" data-verso-hover="67">P</span> <span class="var token" data-binding="var-_uniq.13172" data-verso-hover="67">Q</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.12998" data-verso-hover="61">hyp</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span> <span class="unknown token" data-binding="">|</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.unreachable-10978" data-verso-hover="195">unreachable!</span>

  -- ensure that the conclusion of `h` matches the target
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-11052">unless</span> <span class="var token" data-binding="var-_uniq.13172" data-verso-hover="67">Q</span> <span class="unknown token" data-binding="">==</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainTarget" data-verso-hover="127">getMainTarget</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-11052">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.termThrowError__-11091" data-verso-hover="88">throwError</span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-11102">m!</span><span class="unknown token" data-binding="">"The type of the conclusion of {</span><span class="var token" data-binding="var-_uniq.12928" data-verso-hover="95">h</span><span class="unknown token" data-binding="">}
    does not match the current target."</span>

  -- create a new goal of type `P`
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-11217">let</span> <span class="var token" data-binding="var-_uniq.13904" data-verso-hover="67">newGoal</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-createGoal'" data-verso-hover="190">createGoal'</span> <span class="var token" data-binding="var-_uniq.13171" data-verso-hover="67">P</span>

  -- close off the current goal with `h newGoal`
  <span class="const token" data-binding="const-proveGoal" data-verso-hover="156">proveGoal</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Expr.app" data-verso-hover="196">.app</span> <span class="var token" data-binding="var-_uniq.12998" data-verso-hover="61">hyp</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.toExpr" data-verso-hover="133">toExpr</span> <span class="var token" data-binding="var-_uniq.13904" data-verso-hover="67">newGoal</span><span class="unknown token" data-binding="">)</span>


<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-11337">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.15972" data-verso-hover="197">h</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">4</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">4</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-1902030517956966297-11381-11383"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-11381" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-1902030517956966297-11381-11383"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15972" data-verso-hover="197">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2 → <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-15581974802753817595-11386-11404"><span class="keyword token" data-binding="kw-occ-tacticApply_hypothesis_-11386">apply_hypothesis</span> <span class="var token" data-binding="var-_uniq.15972" data-verso-hover="197">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15581974802753817595-11386-11404"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.15972" data-verso-hover="197">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2 → <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2</span></span></span></span></span> -- the goal is now `Even 2`
  <span class="tactic"><label for="tactic-state-7-11435-11456"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-11435" data-verso-hover="76">rw</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-even_iff_two_dvd" data-verso-hover="199">even_iff_two_dvd</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-11435-11456"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
              However, our implementation has some shortcomings. Let's try to change the target to <code>Even (2 * 2)</code> instead of <code>Even 4</code>:</p>
            <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-11608">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.19823" data-verso-hover="197">h</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">4</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">*</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-15797761117554524672-11658-11660"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-11658" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15797761117554524672-11658-11660"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19823" data-verso-hover="197">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2 → <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">(</span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200"> * </span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">)</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-15797761117554524672-11663-11681"><span class="has-info error"><span class="hover-container"><span class="hover-info messages"><code class="message error">The type of the conclusion of h
    does not match the current target.</code></span></span><span class="keyword token" data-binding="kw-occ-tacticApply_hypothesis_-11663">apply_hypothesis</span></span> <span class="var token" data-binding="var-_uniq.19823" data-verso-hover="197">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15797761117554524672-11663-11681"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.19823" data-verso-hover="197">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2 → <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">(</span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200"> * </span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">)</span></span></span></span></span></span> -- a type mismatch error
<span class="unknown token" data-binding=""></span></code><p>
              We get a type mismatch error since Lean can't tell that <code>Even 4</code> is the same as <code>Even (2 * 2)</code>, even though they are equal by definition. This is because our comparison of expressions in the code uses "Boolean equality" (denoted <code>==</code>), which is too strict for our purposes.</p>
            <p>
              The error goes away when we switch to the coarser notion of "definitional equality" (checked by the function <code>isDefEq</code>):</p>
            <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-12121">elab</span> <span class="literal string token" data-binding="" data-verso-hover="201">"apply_hypothesis_defeq"</span> <span class="var token" data-binding="var-_uniq.18983" data-verso-hover="95">h</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="99">term</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span>
<span class="const token" data-binding="const-Lean.Elab.Tactic.withMainContext" data-verso-hover="81">withMainContext</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-12186">do</span>
    -- ensure that the hypothesis is an implication
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-12243">let</span> <span class="var token" data-binding="var-_uniq.19053" data-verso-hover="61">hyp</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getHypothesisByTerm" data-verso-hover="94">getHypothesisByTerm</span> <span class="var token" data-binding="var-_uniq.18983" data-verso-hover="95">h</span>
  <span class="const token" data-binding="const-guard" data-verso-hover="192">guard</span> <span class="var token" data-binding="var-_uniq.19053" data-verso-hover="61">hyp</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.Expr.isArrow" data-verso-hover="193">isArrow</span>

  -- extract the implication's antecedent & consequent
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetElse-12360">let</span> <span class="const token" data-binding="const-Lean.Expr.forallE" data-verso-hover="194">.forallE</span> <span class="unknown token" data-binding="">_</span> <span class="var token" data-binding="var-_uniq.19226" data-verso-hover="67">P</span> <span class="var token" data-binding="var-_uniq.19227" data-verso-hover="67">Q</span> <span class="unknown token" data-binding="">_</span> <span class="unknown token" data-binding="">:=</span> <span class="var token" data-binding="var-_uniq.19053" data-verso-hover="61">hyp</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span> <span class="unknown token" data-binding="">|</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.unreachable-12395" data-verso-hover="195">unreachable!</span>

  -- ensure that the conclusion of `h` matches the target
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-12469">unless</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="var token" data-binding="var-_uniq.19227" data-verso-hover="67">Q</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.getMainTarget" data-verso-hover="127">getMainTarget</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-12469">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.termThrowError__-12517" data-verso-hover="88">throwError</span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-12528">m!</span><span class="unknown token" data-binding="">"The type of the conclusion of {</span><span class="var token" data-binding="var-_uniq.18983" data-verso-hover="95">h</span><span class="unknown token" data-binding="">}
    does not match the current target."</span>

   -- create a new goal of type `P`
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-12644">let</span> <span class="var token" data-binding="var-_uniq.20141" data-verso-hover="67">newGoal</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-createGoal'" data-verso-hover="190">createGoal'</span> <span class="var token" data-binding="var-_uniq.19226" data-verso-hover="67">P</span>

  -- close off the current goal with `h newGoal`
  <span class="const token" data-binding="const-proveGoal" data-verso-hover="156">proveGoal</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Expr.app" data-verso-hover="196">.app</span> <span class="var token" data-binding="var-_uniq.19053" data-verso-hover="61">hyp</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.toExpr" data-verso-hover="133">toExpr</span> <span class="var token" data-binding="var-_uniq.20141" data-verso-hover="67">newGoal</span><span class="unknown token" data-binding="">)</span>

<span class="unknown token" data-binding=""></span></code><p>
              Now the example works as intended.</p>
            <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-12814">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.22182" data-verso-hover="197">h</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">4</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">*</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-3569499991070663058-12864-12866"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-12864" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-3569499991070663058-12864-12866"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.22182" data-verso-hover="197">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2 → <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">(</span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200"> * </span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">)</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-5929488389429362824-12869-12893"><span class="keyword token" data-binding="kw-occ-tacticApply_hypothesis_defeq_-12869">apply_hypothesis_defeq</span> <span class="var token" data-binding="var-_uniq.22182" data-verso-hover="197">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5929488389429362824-12869-12893"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.22182" data-verso-hover="197">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2 → <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2</span></span></span></span></span> -- the goal is now `Even 2`
  <span class="tactic"><label for="tactic-state-7-12924-12945"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-12924" data-verso-hover="76">rw</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-even_iff_two_dvd" data-verso-hover="199">even_iff_two_dvd</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-12924-12945"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></section>
          </section>
        <section>
          <h2>
            Implementing the 'apply' Tactic via Unification</h2>
          <p>
            As mentioned before, the function <code>isDefEq</code> does more than just checking for definitional equality - it also handles the <strong>unification</strong> (roughly, filling in holes) of <strong>expressions containing meta-variables</strong> (roughly, expressions with holes).</p>
          <p>
            For example, consider the two expressions <code>(7 * _)</code> and <code>(_ * 3)</code>, where the underscores indicate "holes" in the expressions. While these expressions are not equal by <code>==</code>, they are by <code>isDefEq</code>, since they can be made equal by choosing the values for the holes appropriately (so that they both become <code>7 * 3</code>). This is the idea behind <strong>unification</strong>, and the <code>isDefEq</code> function tries to fill in the holes as much as possible to make the two expressions match up.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-13719">elab</span> <span class="literal string token" data-binding="" data-verso-hover="202">"try_to_unify"</span> <span class="var token" data-binding="var-_uniq.26386" data-verso-hover="95">a</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="99">term</span> <span class="literal string token" data-binding="" data-verso-hover="203">"and"</span> <span class="var token" data-binding="var-_uniq.26376" data-verso-hover="95">b</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="99">term</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-13771">do</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-13776">let</span> <span class="var token" data-binding="var-_uniq.26672" data-verso-hover="67">a</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Term.elabTermAndSynthesize" data-verso-hover="204">Term.elabTermAndSynthesize</span> <span class="var token" data-binding="var-_uniq.26386" data-verso-hover="95">a</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="142">none</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-13822">let</span> <span class="var token" data-binding="var-_uniq.26811" data-verso-hover="67">b</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Term.elabTermAndSynthesize" data-verso-hover="204">Term.elabTermAndSynthesize</span> <span class="var token" data-binding="var-_uniq.26376" data-verso-hover="95">b</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="142">none</span>

  -- use isDefEq to compare expressions
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-13909">let</span> <span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">unused variable `aEqB`
note: this linter can be disabled with `set_option linter.unusedVariables false`</code></span></span><span class="var token" data-binding="var-_uniq.26989" data-verso-hover="205">aEqB</span></span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="var token" data-binding="var-_uniq.26672" data-verso-hover="67">a</span> <span class="var token" data-binding="var-_uniq.26811" data-verso-hover="67">b</span>

  --... but the expressions still aren't exactly equal
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-13992">let</span> <span class="var token" data-binding="var-_uniq.26998" data-verso-hover="205">aEqB</span> <span class="unknown token" data-binding="">:=</span>  <span class="var token" data-binding="var-_uniq.26672" data-verso-hover="67">a</span> <span class="unknown token" data-binding="">==</span> <span class="var token" data-binding="var-_uniq.26811" data-verso-hover="67">b</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="10">logInfo</span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-14022">m!</span><span class="unknown token" data-binding="">"It is {</span><span class="var token" data-binding="var-_uniq.26998" data-verso-hover="205">aEqB</span><span class="unknown token" data-binding="">} that expressions a and b are exactly equal
   (according to ==)."</span>

  -- use instantiateMVars to find out how isDefEq filled the holes
  -- and fill them accordingly
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-14205">let</span> <span class="var token" data-binding="var-_uniq.27843" data-verso-hover="67">a</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.instantiateMVars" data-verso-hover="206">instantiateMVars</span> <span class="var token" data-binding="var-_uniq.26672" data-verso-hover="67">a</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-14236">let</span> <span class="var token" data-binding="var-_uniq.27908" data-verso-hover="67">b</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.instantiateMVars" data-verso-hover="206">instantiateMVars</span> <span class="var token" data-binding="var-_uniq.27843" data-verso-hover="67">a</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLet-14267">let</span> <span class="var token" data-binding="var-_uniq.27914" data-verso-hover="205">aEqB</span> <span class="unknown token" data-binding="">:=</span>  <span class="var token" data-binding="var-_uniq.27843" data-verso-hover="67">a</span> <span class="unknown token" data-binding="">==</span> <span class="var token" data-binding="var-_uniq.27908" data-verso-hover="67">b</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="10">logInfo</span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-14297">m!</span><span class="unknown token" data-binding="">"It is {</span><span class="var token" data-binding="var-_uniq.27914" data-verso-hover="205">aEqB</span><span class="unknown token" data-binding="">} that expressions a and b are exactly equal,
   after using unification to fill holes."</span>

  -- show vars after using unification to fill hole
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="10">logInfo</span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-14463">m!</span><span class="unknown token" data-binding="">"This is a after filling holes: {</span><span class="var token" data-binding="var-_uniq.27843" data-verso-hover="67">a</span><span class="unknown token" data-binding="">}"</span>
  <span class="const token" data-binding="const-Lean.logInfo" data-verso-hover="10">logInfo</span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-14512">m!</span><span class="unknown token" data-binding="">"This is b after filling holes: {</span><span class="var token" data-binding="var-_uniq.27908" data-verso-hover="67">b</span><span class="unknown token" data-binding="">}"</span>
<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-14551">example</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-True" data-verso-hover="4">True</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-18227709649813847970-14569-14571"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-14569" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18227709649813847970-14569-14571"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-True" data-verso-hover="4">True</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-18227709649813847970-14574-14602"><span class="has-info warning"><span class="hover-container"><span class="hover-info messages"><code class="message warning">'try_to_unify(_ + 7)and(3 + _)' tactic does nothing
note: this linter can be disabled with `set_option linter.unusedTactic false`</code><code class="message info">It is false that expressions a and b are exactly equal
   (according to ==).</code><code class="message info">It is true that expressions a and b are exactly equal,
   after using unification to fill holes.</code><code class="message info">This is a after filling holes: 3 + 7</code><code class="message info">This is b after filling holes: 3 + 7</code></span></span><span class="keyword token" data-binding="kw-occ-tacticTry_to_unify_And_-14574">try_to_unify</span></span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">+</span><span class="typed token" data-binding="" data-verso-hover="11">7</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-tacticTry_to_unify_And_-14574">and</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="11">3</span><span class="unknown token" data-binding="">+</span><span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">)</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-18227709649813847970-14574-14602"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-True" data-verso-hover="4">True</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-14605-14609"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.simp-14605" data-verso-hover="37">simp</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-14605-14609"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code><p>
            The word <strong>meta-variable</strong> was used earlier to refer to a <em>goal</em> in the tactic, and here is used to refer to a <em>hole</em> in an expression. However, the two senses of the word are essentially the same — a goal can be thought of as a hole for a proof of the appropriate type.</p>
          <p>
            We can implement the <code>apply_hypothesis</code> using a strategy involving unification:</p>
          <ul>
            <li>
              <p>
                We start with a hypothesis <code>h</code> of  type H, and a goal of type <code>Q</code>.</p>
              </li>
            </ul>
          <pre>h: H
======
⊢ Q
</pre><ul>
            <li>
              <p>
                Create a meta-variable <code>?P</code> for the type of the new goal</p>
              </li>
            </ul>
          <pre>h: H
======
⊢ ?P
⊢ Q
</pre><ul>
            <li>
              <p>
                Check whether the type of the hypothesis unifies with the expression <code>?P → Q</code> (which really means <code>anything → Q</code>).</p>
              </li>
            </ul>
          <pre>h: H -- does this take the form (something → Q)?
======
⊢ ?P
⊢ Q
</pre><ul>
            <li>
              <p>
                If the unification succeeds and the meta-variable <code>?P</code> is assigned the value <code>P</code>, create a meta-variable of type <code>P</code> for the new goal</p>
              </li>
            </ul>
          <pre>h: P → Q
======
⊢ P -- it suffices to prove "P"
⊢ Q
</pre><ul>
            <li>
              <p>
                Assign the value <code>h p</code> to the goal of type "Q"</p>
              </li>
            </ul>
          <pre>h: P → Q
======
⊢ P
-- ⊢ Q -- we've proven this
</pre><ul>
            <li>
              <p>
                We're done.</p>
              </li>
            </ul>
          <pre>h: P → Q
======
⊢ P
</pre><p>
            With this approach, we no longer need to check if the hypothesis is an implication and explicitly extract its antecedent and consequent.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-15865">elab</span> <span class="literal string token" data-binding="" data-verso-hover="207">"apply_hypothesis_unif"</span> <span class="var token" data-binding="var-_uniq.29094" data-verso-hover="95">h</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="99">term</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span>
<span class="const token" data-binding="const-Lean.Elab.Tactic.withMainContext" data-verso-hover="81">withMainContext</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-15929">do</span>
  -- get the hypothesis
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-15958">let</span> <span class="var token" data-binding="var-_uniq.29164" data-verso-hover="61">hyp</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getHypothesisByTerm" data-verso-hover="94">getHypothesisByTerm</span> <span class="var token" data-binding="var-_uniq.29094" data-verso-hover="95">h</span>

  -- call the current goal Q
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-16024">let</span> <span class="var token" data-binding="var-_uniq.29192" data-verso-hover="67">Q</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getGoalType" data-verso-hover="208">getGoalType</span>

  -- try to unify hypothesis with `P? → Q`
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-16094">let</span> <span class="var token" data-binding="var-_uniq.29398" data-verso-hover="67">P?</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.mkFreshExprMVar" data-verso-hover="144">mkFreshExprMVar</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="142">none</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-16128">unless</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="var token" data-binding="var-_uniq.29164" data-verso-hover="61">hyp</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.type" data-verso-hover="68">type</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.mkArrow" data-verso-hover="209">mkArrow</span> <span class="var token" data-binding="var-_uniq.29398" data-verso-hover="67">P?</span> <span class="var token" data-binding="var-_uniq.29192" data-verso-hover="67">Q</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-16128">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.termThrowError__-16182" data-verso-hover="88">throwError</span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-16193">m!</span><span class="unknown token" data-binding="">"The hypothesis is expected to be an implication
      with conclusion matching the current goal."</span>

  -- fill in holes in `P` with what made it unify with `P?`
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-16357">let</span> <span class="var token" data-binding="var-_uniq.30380" data-verso-hover="67">P</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.instantiateMVars" data-verso-hover="206">instantiateMVars</span> <span class="var token" data-binding="var-_uniq.29398" data-verso-hover="67">P?</span>

  -- create a new goal of type `P`
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-16425">let</span> <span class="var token" data-binding="var-_uniq.30417" data-verso-hover="67">newGoal</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-createGoal'" data-verso-hover="190">createGoal'</span> <span class="var token" data-binding="var-_uniq.30380" data-verso-hover="67">P</span>

  -- close off the current goal with `h newGoal`
  <span class="const token" data-binding="const-proveGoal" data-verso-hover="156">proveGoal</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.Expr.app" data-verso-hover="196">.app</span> <span class="var token" data-binding="var-_uniq.29164" data-verso-hover="61">hyp</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Lean.LocalDecl.toExpr" data-verso-hover="133">toExpr</span> <span class="var token" data-binding="var-_uniq.30417" data-verso-hover="67">newGoal</span><span class="unknown token" data-binding="">)</span>
<span class="unknown token" data-binding=""></span></code><p>
            And the tactic works the same as before.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-16601">example</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.31616" data-verso-hover="197">h</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">→</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="typed token" data-binding="" data-verso-hover="11">4</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">*</span> <span class="typed token" data-binding="" data-verso-hover="11">2</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-5967102847509464694-16651-16653"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-16651" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-5967102847509464694-16651-16653"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.31616" data-verso-hover="197">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2 → <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> <span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">(</span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200"> * </span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">)</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7174947138356864083-16656-16679"><span class="keyword token" data-binding="kw-occ-tacticApply_hypothesis_unif_-16656">apply_hypothesis_unif</span> <span class="var token" data-binding="var-_uniq.31616" data-verso-hover="197">h</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7174947138356864083-16656-16679"><span class="tactic-state"><span class="goal"><span class="hypotheses"><span class="hypothesis"><span class="name"><span class="var token" data-binding="var-_uniq.31616" data-verso-hover="197">h</span></span><span class="colon">:</span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2 → <span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 4</span></span></span><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Even" data-verso-hover="198">Even</span> 2</span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-7-16682-16703"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.rwSeq-16682" data-verso-hover="76">rw</span> <span class="unknown token" data-binding="">[</span><span class="const token" data-binding="const-even_iff_two_dvd" data-verso-hover="199">even_iff_two_dvd</span><span class="unknown token" data-binding="">]</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-16682-16703"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></section>
        <section>
          <h2>
            Generalizing the 'apply' Tactic</h2>
          <p>
            To finish off this chapter, we'll generalize our <code>apply_hypothesis</code> tactic to scenarios where the type of the argument is not just a single implication.  (The <a href="https://leanprover-community.github.io/lean4-metaprogramming-book/main/04_metam.html?highlight=apply#deconstructing-expressions">Lean 4 Metaprogramming Book</a> goes through this example in detail.)</p>
          <p>
            For example, suppose we have a target like <code>¬Nat.Prime (2 * 3)</code> that we want to prove by backwards reasoning using <code>Nat.not_prime_mul</code> (shown below), which says that the product of two numbers is not prime when those numbers are both not equal to 1.</p>
          <code class="hl lean block" data-lean-context="AGH"><span class="has-info info"><span class="hover-container"><span class="hover-info messages"><code class="message info">Nat.not_prime_mul {a b : ℕ} (a1 : a ≠ 1) (b1 : b ≠ 1) : ¬Nat.Prime (a * b)</code></span></span><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.check-17366">#check</span></span> <span class="const token" data-binding="const-Nat.not_prime_mul" data-verso-hover="210">Nat.not_prime_mul</span>
<span class="unknown token" data-binding=""></span></code><p>
            We would like our <code>apply</code> tactic to infer values of the implicit parameters <code>a</code> and <code>b</code> through unification and create two new goals corresponding to the remaining arguments: <code>2 ≠ 1</code> and <code>3 ≠ 1</code>.</p>
          <p>
            Lean contains utilities for taking expressions of the form <code>P₁ → (P₂ → ... → Pₖ → (... → Q))</code> and extracting the hypotheses <code>#[P₁, P₂, ..., Pₖ, ...]</code> along with the conclusion <code>Q</code> (which go under the fanciful name of "telescopes"). These turn out to be exactly what we need to implement a version of the <code>apply</code> tactic that does what we want.</p>
          <p>
            Here is our rough strategy for implementing the tactic:</p>
          <ul>
            <li>
              <p>
                Infer the type of the hypothesis being applied</p>
              </li>
            <li>
              <p>
                Using a telescope, obtain the list of meta-variables <code>#[p₁, p₂, ..., pₖ, ...]</code> for the conditions along with the conclusion <code>Q</code></p>
              </li>
            <li>
              <p>
                Attempt to unify <code>Q</code> with the current target</p>
              </li>
            <li>
              <p>
                Assign the value <code>h p₁ p₂ ... pₖ ...</code> to the current goal, where <code>h</code> is the hypothesis being applied</p>
              </li>
            <li>
              <p>
                Make the hypotheses <code>#[P₁, P₂, ..., Pₖ, ...]</code> the new targets</p>
              </li>
            </ul>
          <code class="hl lean block" data-lean-context="AGH"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.elab-18447">elab</span> <span class="literal string token" data-binding="" data-verso-hover="211">"apply_to_target"</span> <span class="var token" data-binding="var-_uniq.35793" data-verso-hover="95">h</span><span class="unknown token" data-binding="">:</span><span class="const token" data-binding="const-Lean.Parser.Category.term" data-verso-hover="99">term</span> <span class="unknown token" data-binding="">:</span> <span class="const token" data-binding="const-Lean.Parser.Category.tactic" data-verso-hover="2">tactic</span> <span class="unknown token" data-binding="">=&gt;</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.withMainContext" data-verso-hover="81">withMainContext</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.do-18505">do</span>
  -- Get the hypothesis being applied
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-18548">let</span> <span class="var token" data-binding="var-_uniq.35991" data-verso-hover="67">hypTerm</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Elab.Tactic.elabTerm" data-verso-hover="212">elabTerm</span> <span class="var token" data-binding="var-_uniq.35793" data-verso-hover="95">h</span> <span class="const token" data-binding="const-Option.none" data-verso-hover="142">none</span>
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-18582">let</span> <span class="var token" data-binding="var-_uniq.36194" data-verso-hover="67">hypType</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.inferType" data-verso-hover="175">inferType</span> <span class="var token" data-binding="var-_uniq.35991" data-verso-hover="67">hypTerm</span>

  -- Obtain conditions and the conclusion using a telescope
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-18679">let</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.36270" data-verso-hover="213">conditions</span><span class="unknown token" data-binding="">,</span> <span class="unknown token" data-binding="">_</span><span class="unknown token" data-binding="">,</span> <span class="var token" data-binding="var-_uniq.36272" data-verso-hover="67">conclusion</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.forallMetaTelescope" data-verso-hover="214">forallMetaTelescope</span> <span class="var token" data-binding="var-_uniq.36194" data-verso-hover="67">hypType</span>

  -- Attempt to unify the conclusion with the main target
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-18804">unless</span> <span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-Lean.Meta.isDefEq" data-verso-hover="130">isDefEq</span> <span class="var token" data-binding="var-_uniq.36272" data-verso-hover="67">conclusion</span> <span class="unknown token" data-binding="">(</span><span class="unknown token" data-binding="">←</span> <span class="const token" data-binding="const-getGoalType" data-verso-hover="208">getGoalType</span><span class="unknown token" data-binding="">)</span> <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doUnless-18804">do</span>
    <span class="keyword token" data-binding="kw-occ-Lean.termThrowError__-18859" data-verso-hover="88">throwError</span> <span class="keyword token" data-binding="kw-occ-Lean.termM!_-18870">m!</span><span class="unknown token" data-binding="">"The conclusion of the hypothesis {</span><span class="var token" data-binding="var-_uniq.35793" data-verso-hover="95">h</span><span class="unknown token" data-binding="">}
    does not match with the current target."</span>

  -- Fill holes in conditions via unification
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.doLetArrow-19004">let</span> <span class="var token" data-binding="var-_uniq.37149" data-verso-hover="213">conditions</span> <span class="unknown token" data-binding="">←</span> <span class="var token" data-binding="var-_uniq.36270" data-verso-hover="213">conditions</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Array.mapM" data-verso-hover="215">mapM</span> <span class="const token" data-binding="const-Lean.instantiateMVars" data-verso-hover="206">instantiateMVars</span>

  -- Set the conditions as the new goals
  <span class="const token" data-binding="const-Lean.Elab.Tactic.appendGoals" data-verso-hover="145">appendGoals</span> <span class="unknown token" data-binding="">(</span><span class="var token" data-binding="var-_uniq.37149" data-verso-hover="213">conditions</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-Array.toList" data-verso-hover="216">toList</span><span class="unknown token" data-binding="">.</span><span class="const token" data-binding="const-List.map" data-verso-hover="117">map</span> <span class="const token" data-binding="const-Lean.Expr.mvarId!" data-verso-hover="146">Expr.mvarId!</span><span class="unknown token" data-binding="">)</span>

  -- Assign the conclusion to the current goal
  <span class="const token" data-binding="const-proveGoal" data-verso-hover="156">proveGoal</span> <span class="unknown token" data-binding="">(</span><span class="const token" data-binding="const-Lean.mkAppN" data-verso-hover="217">mkAppN</span> <span class="var token" data-binding="var-_uniq.35991" data-verso-hover="67">hypTerm</span> <span class="var token" data-binding="var-_uniq.37149" data-verso-hover="213">conditions</span><span class="unknown token" data-binding="">)</span>

<span class="keyword token" data-binding="kw-occ-Lean.Parser.Command.example-19238">example</span> <span class="unknown token" data-binding="">:</span> <span class="unknown token" data-binding="">¬</span> <span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> <span class="unknown token" data-binding="">(</span><span class="typed token" data-binding="" data-verso-hover="11">2</span> <span class="unknown token" data-binding="">*</span> <span class="typed token" data-binding="" data-verso-hover="11">3</span><span class="unknown token" data-binding="">)</span> <span class="unknown token" data-binding="">:=</span> <span class="tactic"><label for="tactic-state-15667849714581423811-19272-19274"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Term.byTactic-19272" data-verso-hover="5">by</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-15667849714581423811-19272-19274"><span class="tactic-state"><span class="goal"><span class="conclusion"><span class="prefix">⊢ </span><span class="type"><span class="const token" data-binding="const-Not" data-verso-hover="30">¬</span><span class="const token" data-binding="const-Nat.Prime" data-verso-hover="153">Nat.Prime</span> <span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">(</span>2<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200"> * </span>3<span class="const token" data-binding="const-HMul.hMul" data-verso-hover="200">)</span></span></span></span></span></span>
  <span class="tactic"><label for="tactic-state-6684138446022811528-19277-19310"><span class="keyword token" data-binding="kw-occ-tacticApply_to_target_-19277">apply_to_target</span> <span class="const token" data-binding="const-Nat.not_prime_mul" data-verso-hover="210">Nat.not_prime_mul</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-6684138446022811528-19277-19310"><span class="tactic-state"><span class="goal"><span class="labeled-case" checked="checked"><label class="case-label"><input type="checkbox" id="--verso-unique-112" checked="checked"><span for="--verso-unique-112" class="goal-name">a1</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type">2<span class="const token" data-binding="const-Ne" data-verso-hover="218"> ≠ </span>1</span></span></span></span><span class="goal"><span class="labeled-case"><label class="case-label"><input type="checkbox" id="--verso-unique-113"><span for="--verso-unique-113" class="goal-name">b1</span></label><span class="conclusion"><span class="prefix">⊢ </span><span class="type">3<span class="const token" data-binding="const-Ne" data-verso-hover="218"> ≠ </span>1</span></span></span></span></span></span>
  -- the two new goals are `2 ≠ 1` and `3 ≠ 1`
  <span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.allGoals-19364" data-verso-hover="20">all_goals</span> <span class="tactic"><label for="tactic-state-7-19374-19380"><span class="keyword token" data-binding="kw-occ-Lean.Parser.Tactic.decide-19374" data-verso-hover="189">decide</span></label><input type="checkbox" class="tactic-toggle" id="tactic-state-7-19374-19380"><span class="tactic-state">All goals completed! 🐙</span></span>
<span class="unknown token" data-binding=""></span></code></section>
        </div>
      </div>
    </body>
  </html>

